{"map":"{\"version\":3,\"sources\":[\"/home/angeloacr/Proyectos/Tuk/ionic-taxi-4/admin/node_modules/@ionic/core/dist/esm/index-ae28cb4b.js.pre-build-optimizer.js\"],\"names\":[\"__webpack_require__\",\"r\",\"__webpack_exports__\",\"d\",\"create\",\"transitionEnd\",\"el\",\"callback\",\"unRegTrans\",\"opts\",\"passive\",\"unregister\",\"onTransitionEnd\",\"ev\",\"target\",\"addEventListener\",\"removeEventListener\",\"CSS_VALUE_REGEX\",\"DURATION_MIN\",\"TRANSITION_END_FALLBACK_PADDING_MS\",\"TRANSFORM_PROPS\",\"translateX\",\"translateY\",\"translateZ\",\"scale\",\"scaleX\",\"scaleY\",\"scaleZ\",\"rotate\",\"rotateX\",\"rotateY\",\"rotateZ\",\"skewX\",\"skewY\",\"perspective\",\"win\",\"window\",\"raf\",\"requestAnimationFrame\",\"bind\",\"f\",\"Date\",\"now\",\"Animator\",\"[object Object]\",\"this\",\"_hasDur\",\"_hasTweenEffect\",\"_isAsync\",\"_isReverse\",\"_destroyed\",\"hasChildren\",\"isPlaying\",\"hasCompleted\",\"length\",\"i\",\"_addEl\",\"nodeType\",\"_elements\",\"push\",\"childAnimation\",\"parent\",\"_childAnimations\",\"undefined\",\"duration\",\"_duration\",\"getDuration\",\"milliseconds\",\"_reversedEasingName\",\"_easingName\",\"getEasing\",\"name\",\"prop\",\"val\",\"_addProp\",\"clearProperyAfterTransition\",\"fx\",\"afterClearStyles\",\"trans\",\"fromVal\",\"toVal\",\"from\",\"to\",\"_fxProperties\",\"find\",\"effectName\",\"state\",\"fxProp\",\"_getProp\",\"shouldTrans\",\"wc\",\"fxState\",\"num\",\"effectUnit\",\"indexOf\",\"match\",\"parseFloat\",\"isNaN\",\"className\",\"_beforeAddClasses\",\"_beforeRemoveClasses\",\"styles\",\"_beforeStyles\",\"propertyNames\",\"domReadFn\",\"_readCallbacks\",\"domWriteFn\",\"_writeCallbacks\",\"_afterAddClasses\",\"_afterRemoveClasses\",\"_afterStyles\",\"_hasDuration\",\"_clearAsync\",\"_playInit\",\"_playDomInspect\",\"Promise\",\"resolve\",\"onFinish\",\"oneTimeCallback\",\"clearExistingCallbacks\",\"play\",\"children\",\"child\",\"_progress\",\"_willChange\",\"_beforeAnimation\",\"dur\",\"_asyncEnd\",\"_playProgress\",\"_playToStep\",\"_setTrans\",\"_setAfterStyles\",\"_didFinish\",\"stepValue\",\"shouldComplete\",\"self\",\"_unregisterTrnsEnd\",\"_transEl\",\"_playEnd\",\"_didFinishAll\",\"_timerId\",\"setTimeout\",\"_hasDomReads\",\"clearTimeout\",\"elements\",\"effects\",\"j\",\"finalTransform\",\"fromNum\",\"toNum\",\"tweenEffect\",\"style\",\"setProperty\",\"forcedLinearEasing\",\"easing\",\"durString\",\"transitionDuration\",\"transitionTimingFunction\",\"_fireBeforeReadFunc\",\"_fireBeforeWriteFunc\",\"_setBeforeStyles\",\"addClasses\",\"removeClasses\",\"elementClassList\",\"classList\",\"c\",\"add\",\"remove\",\"key\",\"value\",\"Object\",\"entries\",\"readFunctions\",\"writeFunctions\",\"beforeAddClasses\",\"beforeRemoveClasses\",\"beforeStyles\",\"propName\",\"keys\",\"removeProperty\",\"afterAddClasses\",\"afterRemoveClasses\",\"afterStyles\",\"addWillChange\",\"willChange\",\"effect\",\"propWC\",\"join\",\"_progressStart\",\"Math\",\"min\",\"max\",\"progressStep\",\"currentStepValue\",\"diff\",\"abs\",\"_progressEnd\",\"isAsync\",\"_onFinishCallbacks\",\"_onFinishOneTimeCallbacks\",\"finishAsyncAnimations\",\"finishNoDurationAnimations\",\"shouldReverse\",\"reverse\",\"destroy\",\"targetEl\",\"animationBuilder\",\"baseEl\"],\"mappings\":\"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\",\"sourcesContent\":[\"const transitionEnd = (el, callback) => {\\r\\n    let unRegTrans;\\r\\n    const opts = { passive: true };\\r\\n    const unregister = () => {\\r\\n        if (unRegTrans) {\\r\\n            unRegTrans();\\r\\n        }\\r\\n    };\\r\\n    const onTransitionEnd = (ev) => {\\r\\n        if (el === ev.target) {\\r\\n            unregister();\\r\\n            callback(ev);\\r\\n        }\\r\\n    };\\r\\n    if (el) {\\r\\n        el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\\r\\n        el.addEventListener('transitionend', onTransitionEnd, opts);\\r\\n        unRegTrans = () => {\\r\\n            el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\\r\\n            el.removeEventListener('transitionend', onTransitionEnd, opts);\\r\\n        };\\r\\n    }\\r\\n    return unregister;\\r\\n};\\n\\nconst CSS_VALUE_REGEX = /(^-?\\\\d*\\\\.?\\\\d*)(.*)/;\\r\\nconst DURATION_MIN = 32;\\r\\nconst TRANSITION_END_FALLBACK_PADDING_MS = 400;\\r\\nconst TRANSFORM_PROPS = {\\r\\n    'translateX': 1,\\r\\n    'translateY': 1,\\r\\n    'translateZ': 1,\\r\\n    'scale': 1,\\r\\n    'scaleX': 1,\\r\\n    'scaleY': 1,\\r\\n    'scaleZ': 1,\\r\\n    'rotate': 1,\\r\\n    'rotateX': 1,\\r\\n    'rotateY': 1,\\r\\n    'rotateZ': 1,\\r\\n    'skewX': 1,\\r\\n    'skewY': 1,\\r\\n    'perspective': 1\\r\\n};\\r\\nconst win = typeof window !== 'undefined' ? window : {};\\r\\nconst raf = win.requestAnimationFrame\\r\\n    ? win.requestAnimationFrame.bind(win)\\r\\n    : (f) => f(Date.now());\\r\\nclass Animator {\\r\\n    constructor() {\\r\\n        this._hasDur = false;\\r\\n        this._hasTweenEffect = false;\\r\\n        this._isAsync = false;\\r\\n        this._isReverse = false;\\r\\n        this._destroyed = false;\\r\\n        this.hasChildren = false;\\r\\n        this.isPlaying = false;\\r\\n        this.hasCompleted = false;\\r\\n    }\\r\\n    addElement(el) {\\r\\n        if (el != null) {\\r\\n            if (el.length > 0) {\\r\\n                for (let i = 0; i < el.length; i++) {\\r\\n                    this._addEl(el[i]);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                this._addEl(el);\\r\\n            }\\r\\n        }\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * NO DOM\\r\\n     */\\r\\n    _addEl(el) {\\r\\n        if (el.nodeType === 1) {\\r\\n            (this._elements = this._elements || []).push(el);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Add a child animation to this animation.\\r\\n     */\\r\\n    add(childAnimation) {\\r\\n        childAnimation.parent = this;\\r\\n        this.hasChildren = true;\\r\\n        (this._childAnimations = this._childAnimations || []).push(childAnimation);\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Get the duration of this animation. If this animation does\\r\\n     * not have a duration, then it'll get the duration from its parent.\\r\\n     */\\r\\n    getDuration(opts) {\\r\\n        if (opts && opts.duration !== undefined) {\\r\\n            return opts.duration;\\r\\n        }\\r\\n        else if (this._duration !== undefined) {\\r\\n            return this._duration;\\r\\n        }\\r\\n        else if (this.parent) {\\r\\n            return this.parent.getDuration();\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    /**\\r\\n     * Returns if the animation is a root one.\\r\\n     */\\r\\n    isRoot() {\\r\\n        return !this.parent;\\r\\n    }\\r\\n    /**\\r\\n     * Set the duration for this animation.\\r\\n     */\\r\\n    duration(milliseconds) {\\r\\n        this._duration = milliseconds;\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Get the easing of this animation. If this animation does\\r\\n     * not have an easing, then it'll get the easing from its parent.\\r\\n     */\\r\\n    getEasing() {\\r\\n        if (this._isReverse && this._reversedEasingName !== undefined) {\\r\\n            return this._reversedEasingName;\\r\\n        }\\r\\n        return this._easingName !== undefined ? this._easingName : (this.parent && this.parent.getEasing()) || null;\\r\\n    }\\r\\n    /**\\r\\n     * Set the easing for this animation.\\r\\n     */\\r\\n    easing(name) {\\r\\n        this._easingName = name;\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Set the easing for this reversed animation.\\r\\n     */\\r\\n    easingReverse(name) {\\r\\n        this._reversedEasingName = name;\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Add the \\\"from\\\" value for a specific property.\\r\\n     */\\r\\n    from(prop, val) {\\r\\n        this._addProp('from', prop, val);\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Add the \\\"to\\\" value for a specific property.\\r\\n     */\\r\\n    to(prop, val, clearProperyAfterTransition = false) {\\r\\n        const fx = this._addProp('to', prop, val);\\r\\n        if (clearProperyAfterTransition) {\\r\\n            // if this effect is a transform then clear the transform effect\\r\\n            // otherwise just clear the actual property\\r\\n            this.afterClearStyles(fx.trans ? ['transform', '-webkit-transform'] : [prop]);\\r\\n        }\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Shortcut to add both the \\\"from\\\" and \\\"to\\\" for the same property.\\r\\n     */\\r\\n    fromTo(prop, fromVal, toVal, clearProperyAfterTransition) {\\r\\n        return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);\\r\\n    }\\r\\n    /**\\r\\n     * NO DOM\\r\\n     */\\r\\n    _getProp(name) {\\r\\n        if (this._fxProperties) {\\r\\n            return this._fxProperties.find(prop => prop.effectName === name);\\r\\n        }\\r\\n        return undefined;\\r\\n    }\\r\\n    _addProp(state, prop, val) {\\r\\n        let fxProp = this._getProp(prop);\\r\\n        if (!fxProp) {\\r\\n            // first time we've see this EffectProperty\\r\\n            const shouldTrans = (TRANSFORM_PROPS[prop] === 1);\\r\\n            fxProp = {\\r\\n                effectName: prop,\\r\\n                trans: shouldTrans,\\r\\n                // add the will-change property for transforms or opacity\\r\\n                wc: (shouldTrans ? 'transform' : prop)\\r\\n            };\\r\\n            (this._fxProperties = this._fxProperties || []).push(fxProp);\\r\\n        }\\r\\n        // add from/to EffectState to the EffectProperty\\r\\n        const fxState = {\\r\\n            val,\\r\\n            num: 0,\\r\\n            effectUnit: '',\\r\\n        };\\r\\n        fxProp[state] = fxState;\\r\\n        if (typeof val === 'string' && val.indexOf(' ') < 0) {\\r\\n            const r = val.match(CSS_VALUE_REGEX);\\r\\n            if (r) {\\r\\n                const num = parseFloat(r[1]);\\r\\n                if (!isNaN(num)) {\\r\\n                    fxState.num = num;\\r\\n                }\\r\\n                fxState.effectUnit = (r[0] !== r[2] ? r[2] : '');\\r\\n            }\\r\\n        }\\r\\n        else if (typeof val === 'number') {\\r\\n            fxState.num = val;\\r\\n        }\\r\\n        return fxProp;\\r\\n    }\\r\\n    /**\\r\\n     * Add CSS class to this animation's elements\\r\\n     * before the animation begins.\\r\\n     */\\r\\n    beforeAddClass(className) {\\r\\n        (this._beforeAddClasses = this._beforeAddClasses || []).push(className);\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Remove CSS class from this animation's elements\\r\\n     * before the animation begins.\\r\\n     */\\r\\n    beforeRemoveClass(className) {\\r\\n        (this._beforeRemoveClasses = this._beforeRemoveClasses || []).push(className);\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Set CSS inline styles to this animation's elements\\r\\n     * before the animation begins.\\r\\n     */\\r\\n    beforeStyles(styles) {\\r\\n        this._beforeStyles = styles;\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Clear CSS inline styles from this animation's elements\\r\\n     * before the animation begins.\\r\\n     */\\r\\n    beforeClearStyles(propertyNames) {\\r\\n        this._beforeStyles = this._beforeStyles || {};\\r\\n        for (const prop of propertyNames) {\\r\\n            this._beforeStyles[prop] = '';\\r\\n        }\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Add a function which contains DOM reads, which will run\\r\\n     * before the animation begins.\\r\\n     */\\r\\n    beforeAddRead(domReadFn) {\\r\\n        (this._readCallbacks = this._readCallbacks || []).push(domReadFn);\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Add a function which contains DOM writes, which will run\\r\\n     * before the animation begins.\\r\\n     */\\r\\n    beforeAddWrite(domWriteFn) {\\r\\n        (this._writeCallbacks = this._writeCallbacks || []).push(domWriteFn);\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Add CSS class to this animation's elements\\r\\n     * after the animation finishes.\\r\\n     */\\r\\n    afterAddClass(className) {\\r\\n        (this._afterAddClasses = this._afterAddClasses || []).push(className);\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Remove CSS class from this animation's elements\\r\\n     * after the animation finishes.\\r\\n     */\\r\\n    afterRemoveClass(className) {\\r\\n        (this._afterRemoveClasses = this._afterRemoveClasses || []).push(className);\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Set CSS inline styles to this animation's elements\\r\\n     * after the animation finishes.\\r\\n     */\\r\\n    afterStyles(styles) {\\r\\n        this._afterStyles = styles;\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Clear CSS inline styles from this animation's elements\\r\\n     * after the animation finishes.\\r\\n     */\\r\\n    afterClearStyles(propertyNames) {\\r\\n        this._afterStyles = this._afterStyles || {};\\r\\n        for (const prop of propertyNames) {\\r\\n            this._afterStyles[prop] = '';\\r\\n        }\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Play the animation.\\r\\n     */\\r\\n    play(opts) {\\r\\n        // If the animation was already invalidated (it did finish), do nothing\\r\\n        if (this._destroyed) {\\r\\n            return;\\r\\n        }\\r\\n        // this is the top level animation and is in full control\\r\\n        // of when the async play() should actually kick off\\r\\n        // if there is no duration then it'll set the TO property immediately\\r\\n        // if there is a duration, then it'll stage all animations at the\\r\\n        // FROM property and transition duration, wait a few frames, then\\r\\n        // kick off the animation by setting the TO property for each animation\\r\\n        this._isAsync = this._hasDuration(opts);\\r\\n        // ensure all past transition end events have been cleared\\r\\n        this._clearAsync();\\r\\n        // recursively kicks off the correct progress step for each child animation\\r\\n        // ******** DOM WRITE ****************\\r\\n        this._playInit(opts);\\r\\n        // doubling up RAFs since this animation was probably triggered\\r\\n        // from an input event, and just having one RAF would have this code\\r\\n        // run within the same frame as the triggering input event, and the\\r\\n        // input event probably already did way too much work for one frame\\r\\n        raf(() => {\\r\\n            raf(() => {\\r\\n                this._playDomInspect(opts);\\r\\n            });\\r\\n        });\\r\\n    }\\r\\n    playAsync(opts) {\\r\\n        return new Promise(resolve => {\\r\\n            this.onFinish(resolve, { oneTimeCallback: true, clearExistingCallbacks: true });\\r\\n            this.play(opts);\\r\\n            return this;\\r\\n        });\\r\\n    }\\r\\n    playSync() {\\r\\n        // If the animation was already invalidated (it did finish), do nothing\\r\\n        if (!this._destroyed) {\\r\\n            const opts = { duration: 0 };\\r\\n            this._isAsync = false;\\r\\n            this._clearAsync();\\r\\n            this._playInit(opts);\\r\\n            this._playDomInspect(opts);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * RECURSION\\r\\n     */\\r\\n    _playInit(opts) {\\r\\n        // always default that an animation does not tween\\r\\n        // a tween requires that an Animation class has an element\\r\\n        // and that it has at least one FROM/TO effect\\r\\n        // and that the FROM/TO effect can tween numeric values\\r\\n        this._hasTweenEffect = false;\\r\\n        this.isPlaying = true;\\r\\n        this.hasCompleted = false;\\r\\n        this._hasDur = (this.getDuration(opts) > DURATION_MIN);\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                child._playInit(opts);\\r\\n            }\\r\\n        }\\r\\n        if (this._hasDur) {\\r\\n            // if there is a duration then we want to start at step 0\\r\\n            // ******** DOM WRITE ****************\\r\\n            this._progress(0);\\r\\n            // add the will-change properties\\r\\n            // ******** DOM WRITE ****************\\r\\n            this._willChange(true);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * NO RECURSION\\r\\n     * ROOT ANIMATION\\r\\n     */\\r\\n    _playDomInspect(opts) {\\r\\n        // fire off all the \\\"before\\\" function that have DOM READS in them\\r\\n        // elements will be in the DOM, however visibily hidden\\r\\n        // so we can read their dimensions if need be\\r\\n        // ******** DOM READ ****************\\r\\n        // ******** DOM WRITE ****************\\r\\n        this._beforeAnimation();\\r\\n        // for the root animation only\\r\\n        // set the async TRANSITION END event\\r\\n        // and run onFinishes when the transition ends\\r\\n        const dur = this.getDuration(opts);\\r\\n        if (this._isAsync) {\\r\\n            this._asyncEnd(dur, true);\\r\\n        }\\r\\n        // ******** DOM WRITE ****************\\r\\n        this._playProgress(opts);\\r\\n        if (this._isAsync && !this._destroyed) {\\r\\n            // this animation has a duration so we need another RAF\\r\\n            // for the CSS TRANSITION properties to kick in\\r\\n            raf(() => {\\r\\n                this._playToStep(1);\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * RECURSION\\r\\n     */\\r\\n    _playProgress(opts) {\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                child._playProgress(opts);\\r\\n            }\\r\\n        }\\r\\n        if (this._hasDur) {\\r\\n            // set the CSS TRANSITION duration/easing\\r\\n            // ******** DOM WRITE ****************\\r\\n            this._setTrans(this.getDuration(opts), false);\\r\\n        }\\r\\n        else {\\r\\n            // this animation does not have a duration, so it should not animate\\r\\n            // just go straight to the TO properties and call it done\\r\\n            // ******** DOM WRITE ****************\\r\\n            this._progress(1);\\r\\n            // since there was no animation, immediately run the after\\r\\n            // ******** DOM WRITE ****************\\r\\n            this._setAfterStyles();\\r\\n            // this animation has no duration, so it has finished\\r\\n            // other animations could still be running\\r\\n            this._didFinish(true);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * RECURSION\\r\\n     */\\r\\n    _playToStep(stepValue) {\\r\\n        if (!this._destroyed) {\\r\\n            const children = this._childAnimations;\\r\\n            if (children) {\\r\\n                for (const child of children) {\\r\\n                    // ******** DOM WRITE ****************\\r\\n                    child._playToStep(stepValue);\\r\\n                }\\r\\n            }\\r\\n            if (this._hasDur) {\\r\\n                // browser had some time to render everything in place\\r\\n                // and the transition duration/easing is set\\r\\n                // now set the TO properties which will trigger the transition to begin\\r\\n                // ******** DOM WRITE ****************\\r\\n                this._progress(stepValue);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * NO RECURSION\\r\\n     * ROOT ANIMATION\\r\\n     */\\r\\n    _asyncEnd(dur, shouldComplete) {\\r\\n        const self = this;\\r\\n        const onTransitionEnd = () => {\\r\\n            // congrats! a successful transition completed!\\r\\n            // ensure transition end events and timeouts have been cleared\\r\\n            self._clearAsync();\\r\\n            // ******** DOM WRITE ****************\\r\\n            self._playEnd();\\r\\n            // transition finished\\r\\n            self._didFinishAll(shouldComplete, true, false);\\r\\n        };\\r\\n        const onTransitionFallback = () => {\\r\\n            // oh noz! the transition end event didn't fire in time!\\r\\n            // instead the fallback timer when first\\r\\n            // if all goes well this fallback should never fire\\r\\n            // clear the other async end events from firing\\r\\n            self._timerId = undefined;\\r\\n            self._clearAsync();\\r\\n            // set the after styles\\r\\n            // ******** DOM WRITE ****************\\r\\n            self._playEnd(shouldComplete ? 1 : 0);\\r\\n            // transition finished\\r\\n            self._didFinishAll(shouldComplete, true, false);\\r\\n        };\\r\\n        // set the TRANSITION END event on one of the transition elements\\r\\n        self._unregisterTrnsEnd = transitionEnd(self._transEl(), onTransitionEnd);\\r\\n        // set a fallback timeout if the transition end event never fires, or is too slow\\r\\n        // transition end fallback: (animation duration + XXms)\\r\\n        self._timerId = setTimeout(onTransitionFallback, (dur + TRANSITION_END_FALLBACK_PADDING_MS));\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * RECURSION\\r\\n     */\\r\\n    _playEnd(stepValue) {\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                child._playEnd(stepValue);\\r\\n            }\\r\\n        }\\r\\n        if (this._hasDur) {\\r\\n            if (stepValue !== undefined) {\\r\\n                // too late to have a smooth animation, just finish it\\r\\n                // ******** DOM WRITE ****************\\r\\n                this._setTrans(0, true);\\r\\n                // ensure the ending progress step gets rendered\\r\\n                // ******** DOM WRITE ****************\\r\\n                this._progress(stepValue);\\r\\n            }\\r\\n            // set the after styles\\r\\n            // ******** DOM WRITE ****************\\r\\n            this._setAfterStyles();\\r\\n            // remove the will-change properties\\r\\n            // ******** DOM WRITE ****************\\r\\n            this._willChange(false);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * NO DOM\\r\\n     * RECURSION\\r\\n     */\\r\\n    _hasDuration(opts) {\\r\\n        if (this.getDuration(opts) > DURATION_MIN) {\\r\\n            return true;\\r\\n        }\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                if (child._hasDuration(opts)) {\\r\\n                    return true;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n    /**\\r\\n     * NO DOM\\r\\n     * RECURSION\\r\\n     */\\r\\n    _hasDomReads() {\\r\\n        if (this._readCallbacks && this._readCallbacks.length > 0) {\\r\\n            return true;\\r\\n        }\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                if (child._hasDomReads()) {\\r\\n                    return true;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n    /**\\r\\n     * Immediately stop at the end of the animation.\\r\\n     */\\r\\n    stop(stepValue = 1) {\\r\\n        // ensure all past transition end events have been cleared\\r\\n        this._clearAsync();\\r\\n        this._hasDur = true;\\r\\n        this._playEnd(stepValue);\\r\\n    }\\r\\n    /**\\r\\n     * NO DOM\\r\\n     * NO RECURSION\\r\\n     */\\r\\n    _clearAsync() {\\r\\n        if (this._unregisterTrnsEnd) {\\r\\n            this._unregisterTrnsEnd();\\r\\n        }\\r\\n        if (this._timerId) {\\r\\n            clearTimeout(this._timerId);\\r\\n        }\\r\\n        this._timerId = this._unregisterTrnsEnd = undefined;\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * NO RECURSION\\r\\n     */\\r\\n    _progress(stepValue) {\\r\\n        // bread 'n butter\\r\\n        let val;\\r\\n        const elements = this._elements;\\r\\n        const effects = this._fxProperties;\\r\\n        if (!elements || elements.length === 0 || !effects || this._destroyed) {\\r\\n            return;\\r\\n        }\\r\\n        // flip the number if we're going in reverse\\r\\n        if (this._isReverse) {\\r\\n            stepValue = 1 - stepValue;\\r\\n        }\\r\\n        let i = 0;\\r\\n        let j = 0;\\r\\n        let finalTransform = '';\\r\\n        let fx;\\r\\n        for (i = 0; i < effects.length; i++) {\\r\\n            fx = effects[i];\\r\\n            if (fx.from && fx.to) {\\r\\n                const fromNum = fx.from.num;\\r\\n                const toNum = fx.to.num;\\r\\n                const tweenEffect = (fromNum !== toNum);\\r\\n                if (tweenEffect) {\\r\\n                    this._hasTweenEffect = true;\\r\\n                }\\r\\n                if (stepValue === 0) {\\r\\n                    // FROM\\r\\n                    val = fx.from.val;\\r\\n                }\\r\\n                else if (stepValue === 1) {\\r\\n                    // TO\\r\\n                    val = fx.to.val;\\r\\n                }\\r\\n                else if (tweenEffect) {\\r\\n                    // EVERYTHING IN BETWEEN\\r\\n                    const valNum = (((toNum - fromNum) * stepValue) + fromNum);\\r\\n                    const unit = fx.to.effectUnit;\\r\\n                    val = valNum + unit;\\r\\n                }\\r\\n                if (val !== null) {\\r\\n                    const prop = fx.effectName;\\r\\n                    if (fx.trans) {\\r\\n                        finalTransform += prop + '(' + val + ') ';\\r\\n                    }\\r\\n                    else {\\r\\n                        for (j = 0; j < elements.length; j++) {\\r\\n                            // ******** DOM WRITE ****************\\r\\n                            elements[j].style.setProperty(prop, val);\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        // place all transforms on the same property\\r\\n        if (finalTransform.length > 0) {\\r\\n            if (!this._isReverse && stepValue !== 1 || this._isReverse && stepValue !== 0) {\\r\\n                finalTransform += 'translateZ(0px)';\\r\\n            }\\r\\n            for (i = 0; i < elements.length; i++) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                elements[i].style.setProperty('transform', finalTransform);\\r\\n                elements[i].style.setProperty('-webkit-transform', finalTransform);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * NO RECURSION\\r\\n     */\\r\\n    _setTrans(dur, forcedLinearEasing) {\\r\\n        // Transition is not enabled if there are not effects\\r\\n        const elements = this._elements;\\r\\n        if (!elements || elements.length === 0 || !this._fxProperties) {\\r\\n            return;\\r\\n        }\\r\\n        // set the TRANSITION properties inline on the element\\r\\n        const easing = (forcedLinearEasing ? 'linear' : this.getEasing());\\r\\n        const durString = dur + 'ms';\\r\\n        for (const { style } of elements) {\\r\\n            if (dur > 0) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                style.transitionDuration = durString;\\r\\n                // each animation can have a different easing\\r\\n                if (easing !== null) {\\r\\n                    // ******** DOM WRITE ****************\\r\\n                    style.transitionTimingFunction = easing;\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                style.transitionDuration = '0';\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM READ\\r\\n     * DOM WRITE\\r\\n     * RECURSION\\r\\n     */\\r\\n    _beforeAnimation() {\\r\\n        // fire off all the \\\"before\\\" function that have DOM READS in them\\r\\n        // elements will be in the DOM, however visibily hidden\\r\\n        // so we can read their dimensions if need be\\r\\n        // ******** DOM READ ****************\\r\\n        this._fireBeforeReadFunc();\\r\\n        // ******** DOM READS ABOVE / DOM WRITES BELOW ****************\\r\\n        // fire off all the \\\"before\\\" function that have DOM WRITES in them\\r\\n        // ******** DOM WRITE ****************\\r\\n        this._fireBeforeWriteFunc();\\r\\n        // stage all of the before css classes and inline styles\\r\\n        // ******** DOM WRITE ****************\\r\\n        this._setBeforeStyles();\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * RECURSION\\r\\n     */\\r\\n    _setBeforeStyles() {\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                child._setBeforeStyles();\\r\\n            }\\r\\n        }\\r\\n        const elements = this._elements;\\r\\n        // before the animations have started\\r\\n        // only set before styles if animation is not reversed\\r\\n        if (!elements || elements.length === 0 || this._isReverse) {\\r\\n            return;\\r\\n        }\\r\\n        const addClasses = this._beforeAddClasses;\\r\\n        const removeClasses = this._beforeRemoveClasses;\\r\\n        for (const el of elements) {\\r\\n            const elementClassList = el.classList;\\r\\n            // css classes to add before the animation\\r\\n            if (addClasses) {\\r\\n                for (const c of addClasses) {\\r\\n                    // ******** DOM WRITE ****************\\r\\n                    elementClassList.add(c);\\r\\n                }\\r\\n            }\\r\\n            // css classes to remove before the animation\\r\\n            if (removeClasses) {\\r\\n                for (const c of removeClasses) {\\r\\n                    // ******** DOM WRITE ****************\\r\\n                    elementClassList.remove(c);\\r\\n                }\\r\\n            }\\r\\n            // inline styles to add before the animation\\r\\n            if (this._beforeStyles) {\\r\\n                for (const [key, value] of Object.entries(this._beforeStyles)) {\\r\\n                    // ******** DOM WRITE ****************\\r\\n                    el.style.setProperty(key, value);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM READ\\r\\n     * RECURSION\\r\\n     */\\r\\n    _fireBeforeReadFunc() {\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                // ******** DOM READ ****************\\r\\n                child._fireBeforeReadFunc();\\r\\n            }\\r\\n        }\\r\\n        const readFunctions = this._readCallbacks;\\r\\n        if (readFunctions) {\\r\\n            for (const callback of readFunctions) {\\r\\n                // ******** DOM READ ****************\\r\\n                callback();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * RECURSION\\r\\n     */\\r\\n    _fireBeforeWriteFunc() {\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                child._fireBeforeWriteFunc();\\r\\n            }\\r\\n        }\\r\\n        const writeFunctions = this._writeCallbacks;\\r\\n        if (writeFunctions) {\\r\\n            for (const callback of writeFunctions) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                callback();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     */\\r\\n    _setAfterStyles() {\\r\\n        const elements = this._elements;\\r\\n        if (!elements) {\\r\\n            return;\\r\\n        }\\r\\n        for (const el of elements) {\\r\\n            const elementClassList = el.classList;\\r\\n            // remove the transition duration/easing\\r\\n            // ******** DOM WRITE ****************\\r\\n            el.style.transitionDuration = el.style.transitionTimingFunction = '';\\r\\n            if (this._isReverse) {\\r\\n                // finished in reverse direction\\r\\n                // css classes that were added before the animation should be removed\\r\\n                const beforeAddClasses = this._beforeAddClasses;\\r\\n                if (beforeAddClasses) {\\r\\n                    for (const c of beforeAddClasses) {\\r\\n                        elementClassList.remove(c);\\r\\n                    }\\r\\n                }\\r\\n                // css classes that were removed before the animation should be added\\r\\n                const beforeRemoveClasses = this._beforeRemoveClasses;\\r\\n                if (beforeRemoveClasses) {\\r\\n                    for (const c of beforeRemoveClasses) {\\r\\n                        elementClassList.add(c);\\r\\n                    }\\r\\n                }\\r\\n                // inline styles that were added before the animation should be removed\\r\\n                const beforeStyles = this._beforeStyles;\\r\\n                if (beforeStyles) {\\r\\n                    for (const propName of Object.keys(beforeStyles)) {\\r\\n                        // ******** DOM WRITE ****************\\r\\n                        el.style.removeProperty(propName);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                // finished in forward direction\\r\\n                // css classes to add after the animation\\r\\n                const afterAddClasses = this._afterAddClasses;\\r\\n                if (afterAddClasses) {\\r\\n                    for (const c of afterAddClasses) {\\r\\n                        // ******** DOM WRITE ****************\\r\\n                        elementClassList.add(c);\\r\\n                    }\\r\\n                }\\r\\n                // css classes to remove after the animation\\r\\n                const afterRemoveClasses = this._afterRemoveClasses;\\r\\n                if (afterRemoveClasses) {\\r\\n                    for (const c of afterRemoveClasses) {\\r\\n                        // ******** DOM WRITE ****************\\r\\n                        elementClassList.remove(c);\\r\\n                    }\\r\\n                }\\r\\n                // inline styles to add after the animation\\r\\n                const afterStyles = this._afterStyles;\\r\\n                if (afterStyles) {\\r\\n                    for (const [key, value] of Object.entries(afterStyles)) {\\r\\n                        el.style.setProperty(key, value);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * NO RECURSION\\r\\n     */\\r\\n    _willChange(addWillChange) {\\r\\n        let wc;\\r\\n        const effects = this._fxProperties;\\r\\n        let willChange;\\r\\n        if (addWillChange && effects) {\\r\\n            wc = [];\\r\\n            for (const effect of effects) {\\r\\n                const propWC = effect.wc;\\r\\n                if (propWC === 'webkitTransform') {\\r\\n                    wc.push('transform', '-webkit-transform');\\r\\n                }\\r\\n                else if (propWC !== undefined) {\\r\\n                    wc.push(propWC);\\r\\n                }\\r\\n            }\\r\\n            willChange = wc.join(',');\\r\\n        }\\r\\n        else {\\r\\n            willChange = '';\\r\\n        }\\r\\n        const elements = this._elements;\\r\\n        if (elements) {\\r\\n            for (const el of elements) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                el.style.setProperty('will-change', willChange);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Start the animation with a user controlled progress.\\r\\n     */\\r\\n    progressStart() {\\r\\n        // ensure all past transition end events have been cleared\\r\\n        this._clearAsync();\\r\\n        // ******** DOM READ/WRITE ****************\\r\\n        this._beforeAnimation();\\r\\n        // ******** DOM WRITE ****************\\r\\n        this._progressStart();\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * RECURSION\\r\\n     */\\r\\n    _progressStart() {\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                child._progressStart();\\r\\n            }\\r\\n        }\\r\\n        // force no duration, linear easing\\r\\n        // ******** DOM WRITE ****************\\r\\n        this._setTrans(0, true);\\r\\n        // ******** DOM WRITE ****************\\r\\n        this._willChange(true);\\r\\n    }\\r\\n    /**\\r\\n     * Set the progress step for this animation.\\r\\n     * progressStep() is not debounced, so it should not be called faster than 60FPS.\\r\\n     */\\r\\n    progressStep(stepValue) {\\r\\n        // only update if the last update was more than 16ms ago\\r\\n        stepValue = Math.min(1, Math.max(0, stepValue));\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                child.progressStep(stepValue);\\r\\n            }\\r\\n        }\\r\\n        // ******** DOM WRITE ****************\\r\\n        this._progress(stepValue);\\r\\n    }\\r\\n    /**\\r\\n     * End the progress animation.\\r\\n     */\\r\\n    progressEnd(shouldComplete, currentStepValue, dur = -1) {\\r\\n        if (this._isReverse) {\\r\\n            // if the animation is going in reverse then\\r\\n            // flip the step value: 0 becomes 1, 1 becomes 0\\r\\n            currentStepValue = 1 - currentStepValue;\\r\\n        }\\r\\n        const stepValue = shouldComplete ? 1 : 0;\\r\\n        const diff = Math.abs(currentStepValue - stepValue);\\r\\n        if (dur < 0) {\\r\\n            dur = this._duration || 0;\\r\\n        }\\r\\n        else if (diff < 0.05) {\\r\\n            dur = 0;\\r\\n        }\\r\\n        this._isAsync = (dur > 30);\\r\\n        this._progressEnd(shouldComplete, stepValue, dur, this._isAsync);\\r\\n        if (this._isAsync) {\\r\\n            // for the root animation only\\r\\n            // set the async TRANSITION END event\\r\\n            // and run onFinishes when the transition ends\\r\\n            // ******** DOM WRITE ****************\\r\\n            this._asyncEnd(dur, shouldComplete);\\r\\n            // this animation has a duration so we need another RAF\\r\\n            // for the CSS TRANSITION properties to kick in\\r\\n            if (!this._destroyed) {\\r\\n                raf(() => {\\r\\n                    this._playToStep(stepValue);\\r\\n                });\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * DOM WRITE\\r\\n     * RECURSION\\r\\n     */\\r\\n    _progressEnd(shouldComplete, stepValue, dur, isAsync) {\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                // ******** DOM WRITE ****************\\r\\n                child._progressEnd(shouldComplete, stepValue, dur, isAsync);\\r\\n            }\\r\\n        }\\r\\n        if (!isAsync) {\\r\\n            // stop immediately\\r\\n            // set all the animations to their final position\\r\\n            // ******** DOM WRITE ****************\\r\\n            this._progress(stepValue);\\r\\n            this._willChange(false);\\r\\n            this._setAfterStyles();\\r\\n            this._didFinish(shouldComplete);\\r\\n        }\\r\\n        else {\\r\\n            // animate it back to it's ending position\\r\\n            this.isPlaying = true;\\r\\n            this.hasCompleted = false;\\r\\n            this._hasDur = true;\\r\\n            // ******** DOM WRITE ****************\\r\\n            this._willChange(true);\\r\\n            this._setTrans(dur, false);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Add a callback to fire when the animation has finished.\\r\\n     */\\r\\n    onFinish(callback, opts) {\\r\\n        if (opts && opts.clearExistingCallbacks) {\\r\\n            this._onFinishCallbacks = this._onFinishOneTimeCallbacks = undefined;\\r\\n        }\\r\\n        if (opts && opts.oneTimeCallback) {\\r\\n            this._onFinishOneTimeCallbacks = this._onFinishOneTimeCallbacks || [];\\r\\n            this._onFinishOneTimeCallbacks.push(callback);\\r\\n        }\\r\\n        else {\\r\\n            this._onFinishCallbacks = this._onFinishCallbacks || [];\\r\\n            this._onFinishCallbacks.push(callback);\\r\\n        }\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * NO DOM\\r\\n     * RECURSION\\r\\n     */\\r\\n    _didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations) {\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                child._didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations);\\r\\n            }\\r\\n        }\\r\\n        if (finishAsyncAnimations && this._isAsync || finishNoDurationAnimations && !this._isAsync) {\\r\\n            this._didFinish(hasCompleted);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * NO RECURSION\\r\\n     */\\r\\n    _didFinish(hasCompleted) {\\r\\n        this.isPlaying = false;\\r\\n        this.hasCompleted = hasCompleted;\\r\\n        if (this._onFinishCallbacks) {\\r\\n            // run all finish callbacks\\r\\n            for (const callback of this._onFinishCallbacks) {\\r\\n                callback(this);\\r\\n            }\\r\\n        }\\r\\n        if (this._onFinishOneTimeCallbacks) {\\r\\n            // run all \\\"onetime\\\" finish callbacks\\r\\n            for (const callback of this._onFinishOneTimeCallbacks) {\\r\\n                callback(this);\\r\\n            }\\r\\n            this._onFinishOneTimeCallbacks.length = 0;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Reverse the animation.\\r\\n     */\\r\\n    reverse(shouldReverse = true) {\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                child.reverse(shouldReverse);\\r\\n            }\\r\\n        }\\r\\n        this._isReverse = !!shouldReverse;\\r\\n        return this;\\r\\n    }\\r\\n    /**\\r\\n     * Recursively destroy this animation and all child animations.\\r\\n     */\\r\\n    destroy() {\\r\\n        this._didFinish(false);\\r\\n        this._destroyed = true;\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                child.destroy();\\r\\n            }\\r\\n        }\\r\\n        this._clearAsync();\\r\\n        if (this._elements) {\\r\\n            this._elements.length = 0;\\r\\n        }\\r\\n        if (this._readCallbacks) {\\r\\n            this._readCallbacks.length = 0;\\r\\n        }\\r\\n        if (this._writeCallbacks) {\\r\\n            this._writeCallbacks.length = 0;\\r\\n        }\\r\\n        this.parent = undefined;\\r\\n        if (this._childAnimations) {\\r\\n            this._childAnimations.length = 0;\\r\\n        }\\r\\n        if (this._onFinishCallbacks) {\\r\\n            this._onFinishCallbacks.length = 0;\\r\\n        }\\r\\n        if (this._onFinishOneTimeCallbacks) {\\r\\n            this._onFinishOneTimeCallbacks.length = 0;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * NO DOM\\r\\n     */\\r\\n    _transEl() {\\r\\n        // get the lowest level element that has an Animator\\r\\n        const children = this._childAnimations;\\r\\n        if (children) {\\r\\n            for (const child of children) {\\r\\n                const targetEl = child._transEl();\\r\\n                if (targetEl) {\\r\\n                    return targetEl;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return (this._hasTweenEffect &&\\r\\n            this._hasDur &&\\r\\n            this._elements !== undefined &&\\r\\n            this._elements.length > 0 ?\\r\\n            this._elements[0] : null);\\r\\n    }\\r\\n}\\n\\nconst create = (animationBuilder, baseEl, opts) => {\\r\\n    if (animationBuilder) {\\r\\n        return animationBuilder(Animator, baseEl, opts);\\r\\n    }\\r\\n    return Promise.resolve(new Animator());\\r\\n};\\n\\nexport { create };\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{vK52:function(s,t,e){\"use strict\";e.r(t),e.d(t,\"create\",(function(){return f}));const i=(s,t)=>{let e;const i={passive:!0},n=()=>{e&&e()},r=e=>{s===e.target&&(n(),t(e))};return s&&(s.addEventListener(\"webkitTransitionEnd\",r,i),s.addEventListener(\"transitionend\",r,i),e=()=>{s.removeEventListener(\"webkitTransitionEnd\",r,i),s.removeEventListener(\"transitionend\",r,i)}),n},n=/(^-?\\d*\\.?\\d*)(.*)/,r=32,o=400,h={translateX:1,translateY:1,translateZ:1,scale:1,scaleX:1,scaleY:1,scaleZ:1,rotate:1,rotateX:1,rotateY:1,rotateZ:1,skewX:1,skewY:1,perspective:1},a=\"undefined\"!=typeof window?window:{},l=a.requestAnimationFrame?a.requestAnimationFrame.bind(a):s=>s(Date.now());class _{constructor(){this._hasDur=!1,this._hasTweenEffect=!1,this._isAsync=!1,this._isReverse=!1,this._destroyed=!1,this.hasChildren=!1,this.isPlaying=!1,this.hasCompleted=!1}addElement(s){if(null!=s)if(s.length>0)for(let t=0;t<s.length;t++)this._addEl(s[t]);else this._addEl(s);return this}_addEl(s){1===s.nodeType&&(this._elements=this._elements||[]).push(s)}add(s){return s.parent=this,this.hasChildren=!0,(this._childAnimations=this._childAnimations||[]).push(s),this}getDuration(s){return s&&void 0!==s.duration?s.duration:void 0!==this._duration?this._duration:this.parent?this.parent.getDuration():0}isRoot(){return!this.parent}duration(s){return this._duration=s,this}getEasing(){return this._isReverse&&void 0!==this._reversedEasingName?this._reversedEasingName:void 0!==this._easingName?this._easingName:this.parent&&this.parent.getEasing()||null}easing(s){return this._easingName=s,this}easingReverse(s){return this._reversedEasingName=s,this}from(s,t){return this._addProp(\"from\",s,t),this}to(s,t,e=!1){const i=this._addProp(\"to\",s,t);return e&&this.afterClearStyles(i.trans?[\"transform\",\"-webkit-transform\"]:[s]),this}fromTo(s,t,e,i){return this.from(s,t).to(s,e,i)}_getProp(s){if(this._fxProperties)return this._fxProperties.find(t=>t.effectName===s)}_addProp(s,t,e){let i=this._getProp(t);if(!i){const s=1===h[t];i={effectName:t,trans:s,wc:s?\"transform\":t},(this._fxProperties=this._fxProperties||[]).push(i)}const r={val:e,num:0,effectUnit:\"\"};if(i[s]=r,\"string\"==typeof e&&e.indexOf(\" \")<0){const s=e.match(n);if(s){const t=parseFloat(s[1]);isNaN(t)||(r.num=t),r.effectUnit=s[0]!==s[2]?s[2]:\"\"}}else\"number\"==typeof e&&(r.num=e);return i}beforeAddClass(s){return(this._beforeAddClasses=this._beforeAddClasses||[]).push(s),this}beforeRemoveClass(s){return(this._beforeRemoveClasses=this._beforeRemoveClasses||[]).push(s),this}beforeStyles(s){return this._beforeStyles=s,this}beforeClearStyles(s){this._beforeStyles=this._beforeStyles||{};for(const t of s)this._beforeStyles[t]=\"\";return this}beforeAddRead(s){return(this._readCallbacks=this._readCallbacks||[]).push(s),this}beforeAddWrite(s){return(this._writeCallbacks=this._writeCallbacks||[]).push(s),this}afterAddClass(s){return(this._afterAddClasses=this._afterAddClasses||[]).push(s),this}afterRemoveClass(s){return(this._afterRemoveClasses=this._afterRemoveClasses||[]).push(s),this}afterStyles(s){return this._afterStyles=s,this}afterClearStyles(s){this._afterStyles=this._afterStyles||{};for(const t of s)this._afterStyles[t]=\"\";return this}play(s){this._destroyed||(this._isAsync=this._hasDuration(s),this._clearAsync(),this._playInit(s),l(()=>{l(()=>{this._playDomInspect(s)})}))}playAsync(s){return new Promise(t=>(this.onFinish(t,{oneTimeCallback:!0,clearExistingCallbacks:!0}),this.play(s),this))}playSync(){if(!this._destroyed){const s={duration:0};this._isAsync=!1,this._clearAsync(),this._playInit(s),this._playDomInspect(s)}}_playInit(s){this._hasTweenEffect=!1,this.isPlaying=!0,this.hasCompleted=!1,this._hasDur=this.getDuration(s)>r;const t=this._childAnimations;if(t)for(const e of t)e._playInit(s);this._hasDur&&(this._progress(0),this._willChange(!0))}_playDomInspect(s){this._beforeAnimation();const t=this.getDuration(s);this._isAsync&&this._asyncEnd(t,!0),this._playProgress(s),this._isAsync&&!this._destroyed&&l(()=>{this._playToStep(1)})}_playProgress(s){const t=this._childAnimations;if(t)for(const e of t)e._playProgress(s);this._hasDur?this._setTrans(this.getDuration(s),!1):(this._progress(1),this._setAfterStyles(),this._didFinish(!0))}_playToStep(s){if(!this._destroyed){const t=this._childAnimations;if(t)for(const e of t)e._playToStep(s);this._hasDur&&this._progress(s)}}_asyncEnd(s,t){const e=this;e._unregisterTrnsEnd=i(e._transEl(),()=>{e._clearAsync(),e._playEnd(),e._didFinishAll(t,!0,!1)}),e._timerId=setTimeout(()=>{e._timerId=void 0,e._clearAsync(),e._playEnd(t?1:0),e._didFinishAll(t,!0,!1)},s+o)}_playEnd(s){const t=this._childAnimations;if(t)for(const e of t)e._playEnd(s);this._hasDur&&(void 0!==s&&(this._setTrans(0,!0),this._progress(s)),this._setAfterStyles(),this._willChange(!1))}_hasDuration(s){if(this.getDuration(s)>r)return!0;const t=this._childAnimations;if(t)for(const e of t)if(e._hasDuration(s))return!0;return!1}_hasDomReads(){if(this._readCallbacks&&this._readCallbacks.length>0)return!0;const s=this._childAnimations;if(s)for(const t of s)if(t._hasDomReads())return!0;return!1}stop(s=1){this._clearAsync(),this._hasDur=!0,this._playEnd(s)}_clearAsync(){this._unregisterTrnsEnd&&this._unregisterTrnsEnd(),this._timerId&&clearTimeout(this._timerId),this._timerId=this._unregisterTrnsEnd=void 0}_progress(s){let t;const e=this._elements,i=this._fxProperties;if(!e||0===e.length||!i||this._destroyed)return;this._isReverse&&(s=1-s);let n,r=0,o=0,h=\"\";for(r=0;r<i.length;r++)if((n=i[r]).from&&n.to){const i=n.from.num,r=n.to.num,a=i!==r;if(a&&(this._hasTweenEffect=!0),0===s?t=n.from.val:1===s?t=n.to.val:a&&(t=(r-i)*s+i+n.to.effectUnit),null!==t){const s=n.effectName;if(n.trans)h+=s+\"(\"+t+\") \";else for(o=0;o<e.length;o++)e[o].style.setProperty(s,t)}}if(h.length>0)for((!this._isReverse&&1!==s||this._isReverse&&0!==s)&&(h+=\"translateZ(0px)\"),r=0;r<e.length;r++)e[r].style.setProperty(\"transform\",h),e[r].style.setProperty(\"-webkit-transform\",h)}_setTrans(s,t){const e=this._elements;if(!e||0===e.length||!this._fxProperties)return;const i=t?\"linear\":this.getEasing(),n=s+\"ms\";for(const{style:r}of e)s>0?(r.transitionDuration=n,null!==i&&(r.transitionTimingFunction=i)):r.transitionDuration=\"0\"}_beforeAnimation(){this._fireBeforeReadFunc(),this._fireBeforeWriteFunc(),this._setBeforeStyles()}_setBeforeStyles(){const s=this._childAnimations;if(s)for(const n of s)n._setBeforeStyles();const t=this._elements;if(!t||0===t.length||this._isReverse)return;const e=this._beforeAddClasses,i=this._beforeRemoveClasses;for(const n of t){const s=n.classList;if(e)for(const t of e)s.add(t);if(i)for(const t of i)s.remove(t);if(this._beforeStyles)for(const[t,e]of Object.entries(this._beforeStyles))n.style.setProperty(t,e)}}_fireBeforeReadFunc(){const s=this._childAnimations;if(s)for(const e of s)e._fireBeforeReadFunc();const t=this._readCallbacks;if(t)for(const e of t)e()}_fireBeforeWriteFunc(){const s=this._childAnimations;if(s)for(const e of s)e._fireBeforeWriteFunc();const t=this._writeCallbacks;if(t)for(const e of t)e()}_setAfterStyles(){const s=this._elements;if(s)for(const t of s){const s=t.classList;if(t.style.transitionDuration=t.style.transitionTimingFunction=\"\",this._isReverse){const e=this._beforeAddClasses;if(e)for(const t of e)s.remove(t);const i=this._beforeRemoveClasses;if(i)for(const t of i)s.add(t);const n=this._beforeStyles;if(n)for(const s of Object.keys(n))t.style.removeProperty(s)}else{const e=this._afterAddClasses;if(e)for(const t of e)s.add(t);const i=this._afterRemoveClasses;if(i)for(const t of i)s.remove(t);const n=this._afterStyles;if(n)for(const[s,r]of Object.entries(n))t.style.setProperty(s,r)}}}_willChange(s){let t;const e=this._fxProperties;let i;if(s&&e){t=[];for(const s of e){const e=s.wc;\"webkitTransform\"===e?t.push(\"transform\",\"-webkit-transform\"):void 0!==e&&t.push(e)}i=t.join(\",\")}else i=\"\";const n=this._elements;if(n)for(const r of n)r.style.setProperty(\"will-change\",i)}progressStart(){this._clearAsync(),this._beforeAnimation(),this._progressStart()}_progressStart(){const s=this._childAnimations;if(s)for(const t of s)t._progressStart();this._setTrans(0,!0),this._willChange(!0)}progressStep(s){s=Math.min(1,Math.max(0,s));const t=this._childAnimations;if(t)for(const e of t)e.progressStep(s);this._progress(s)}progressEnd(s,t,e=-1){this._isReverse&&(t=1-t);const i=s?1:0,n=Math.abs(t-i);e<0?e=this._duration||0:n<.05&&(e=0),this._isAsync=e>30,this._progressEnd(s,i,e,this._isAsync),this._isAsync&&(this._asyncEnd(e,s),this._destroyed||l(()=>{this._playToStep(i)}))}_progressEnd(s,t,e,i){const n=this._childAnimations;if(n)for(const r of n)r._progressEnd(s,t,e,i);i?(this.isPlaying=!0,this.hasCompleted=!1,this._hasDur=!0,this._willChange(!0),this._setTrans(e,!1)):(this._progress(t),this._willChange(!1),this._setAfterStyles(),this._didFinish(s))}onFinish(s,t){return t&&t.clearExistingCallbacks&&(this._onFinishCallbacks=this._onFinishOneTimeCallbacks=void 0),t&&t.oneTimeCallback?(this._onFinishOneTimeCallbacks=this._onFinishOneTimeCallbacks||[],this._onFinishOneTimeCallbacks.push(s)):(this._onFinishCallbacks=this._onFinishCallbacks||[],this._onFinishCallbacks.push(s)),this}_didFinishAll(s,t,e){const i=this._childAnimations;if(i)for(const n of i)n._didFinishAll(s,t,e);(t&&this._isAsync||e&&!this._isAsync)&&this._didFinish(s)}_didFinish(s){if(this.isPlaying=!1,this.hasCompleted=s,this._onFinishCallbacks)for(const t of this._onFinishCallbacks)t(this);if(this._onFinishOneTimeCallbacks){for(const s of this._onFinishOneTimeCallbacks)s(this);this._onFinishOneTimeCallbacks.length=0}}reverse(s=!0){const t=this._childAnimations;if(t)for(const e of t)e.reverse(s);return this._isReverse=!!s,this}destroy(){this._didFinish(!1),this._destroyed=!0;const s=this._childAnimations;if(s)for(const t of s)t.destroy();this._clearAsync(),this._elements&&(this._elements.length=0),this._readCallbacks&&(this._readCallbacks.length=0),this._writeCallbacks&&(this._writeCallbacks.length=0),this.parent=void 0,this._childAnimations&&(this._childAnimations.length=0),this._onFinishCallbacks&&(this._onFinishCallbacks.length=0),this._onFinishOneTimeCallbacks&&(this._onFinishOneTimeCallbacks.length=0)}_transEl(){const s=this._childAnimations;if(s)for(const t of s){const s=t._transEl();if(s)return s}return this._hasTweenEffect&&this._hasDur&&void 0!==this._elements&&this._elements.length>0?this._elements[0]:null}}const f=(s,t,e)=>s?s(_,t,e):Promise.resolve(new _)}}]);","extractedComments":[]}