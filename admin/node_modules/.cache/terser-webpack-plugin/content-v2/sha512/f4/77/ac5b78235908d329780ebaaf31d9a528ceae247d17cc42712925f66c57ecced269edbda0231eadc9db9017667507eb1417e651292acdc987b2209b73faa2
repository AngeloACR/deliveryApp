{"map":"{\"version\":3,\"sources\":[\"/home/angeloacr/Proyectos/Tuk/ionic-taxi-4/admin/node_modules/@ionic/core/dist/esm/ion-route_4.entry.js.pre-build-optimizer.js\"],\"names\":[\"__webpack_require__\",\"r\",\"__webpack_exports__\",\"d\",\"Route\",\"RouteRedirect\",\"Router\",\"RouterLink\",\"_core_c02a05e9_js__WEBPACK_IMPORTED_MODULE_0__\",\"_theme_353a032e_js__WEBPACK_IMPORTED_MODULE_2__\",\"_helpers_c90aaa66_js__WEBPACK_IMPORTED_MODULE_3__\",\"[object Object]\",\"hostRef\",\"Object\",\"this\",\"url\",\"ionRouteDataChanged\",\"newValue\",\"emit\",\"oldValue\",\"keys1\",\"keys\",\"keys2\",\"length\",\"key\",\"onUpdate\",\"watchers\",\"component\",\"componentProps\",\"ionRouteRedirectChanged\",\"from\",\"to\",\"generatePath\",\"segments\",\"filter\",\"s\",\"join\",\"parsePath\",\"path\",\"split\",\"map\",\"trim\",\"writeNavState\",\"async\",\"root\",\"chain\",\"direction\",\"index\",\"changed\",\"outlet\",\"searchNavNode\",\"componentOnReady\",\"route\",\"result\",\"setRouteId\",\"id\",\"params\",\"element\",\"markVisible\",\"e\",\"console\",\"error\",\"QUERY\",\"matches\",\"querySelector\",\"undefined\",\"routeRedirect\",\"routes\",\"find\",\"input\",\"i\",\"expected\",\"matchesRedirect\",\"matchesIDs\",\"ids\",\"len\",\"Math\",\"min\",\"toLowerCase\",\"matchesPath\",\"inputPath\",\"RouterSegments\",\"allparams\",\"matchesDefault\",\"segment\",\"data\",\"next\",\"slice\",\"mergeParams\",\"a\",\"b\",\"assign\",\"computePriority\",\"score\",\"level\",\"pow\",\"shift\",\"readRedirects\",\"Array\",\"children\",\"el\",\"tagName\",\"readProp\",\"readRoutes\",\"flattenRouterTree\",\"readRouteNodes\",\"node\",\"Error\",\"prop\",\"hasAttribute\",\"getAttribute\",\"nodes\",\"flattenNode\",\"push\",\"sub\",\"previousPath\",\"busy\",\"state\",\"lastState\",\"useHash\",\"ionRouteWillChange\",\"ionRouteDidChange\",\"debug\",\"document\",\"body\",\"Promise\",\"resolve\",\"window\",\"addEventListener\",\"once\",\"waitUntilNavNode\",\"onRoutesChanged\",\"onRedirectChanged\",\"bind\",\"historyDirection\",\"getPath\",\"writeNavStateRoot\",\"ev\",\"detail\",\"register\",\"back\",\"startsWith\",\"URL\",\"location\",\"href\",\"pathname\",\"setPath\",\"history\",\"waitPromise\",\"group\",\"forEach\",\"groupEnd\",\"printRoutes\",\"redirects\",\"redirect\",\"printRedirects\",\"warn\",\"getRouteId\",\"readNavState\",\"chains\",\"match\",\"maxMatches\",\"plainIDs\",\"routerIDsToChain\",\"param\",\"chainToPath\",\"safeWriteNavState\",\"win\",\"replaceState\",\"title\",\"redirectFrom\",\"matchedChain\",\"routerPathToChain\",\"unlock\",\"lock\",\"p\",\"routeEvent\",\"routeChangeEvent\",\"pushState\",\"writePath\",\"loc\",\"hash\",\"prefix\",\"removePrefix\",\"readPath\",\"redirectFromPath\",\"redirectedFrom\",\"routerDirection\",\"onClick\",\"mode\",\"attrs\",\"rel\",\"target\",\"class\",\"color\",\"ion-activatable\",\"style\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { r as registerInstance, c as createEvent, e as getElement, d as getIonMode, h, H as Host } from './core-c02a05e9.js';\\nimport './config-503c2549.js';\\nimport { o as openURL, c as createColorClasses } from './theme-353a032e.js';\\nimport { e as debounce } from './helpers-c90aaa66.js';\\n\\nconst Route = class {\\n    constructor(hostRef) {\\n        registerInstance(this, hostRef);\\n        /**\\n         * Relative path that needs to match in order for this route to apply.\\n         *\\n         * Accepts paths similar to expressjs so that you can define parameters\\n         * in the url /foo/:bar where bar would be available in incoming props.\\n         */\\n        this.url = '';\\n        this.ionRouteDataChanged = createEvent(this, \\\"ionRouteDataChanged\\\", 7);\\n    }\\n    onUpdate(newValue) {\\n        this.ionRouteDataChanged.emit(newValue);\\n    }\\n    onComponentProps(newValue, oldValue) {\\n        if (newValue === oldValue) {\\n            return;\\n        }\\n        const keys1 = newValue ? Object.keys(newValue) : [];\\n        const keys2 = oldValue ? Object.keys(oldValue) : [];\\n        if (keys1.length !== keys2.length) {\\n            this.onUpdate(newValue);\\n            return;\\n        }\\n        for (const key of keys1) {\\n            if (newValue[key] !== oldValue[key]) {\\n                this.onUpdate(newValue);\\n                return;\\n            }\\n        }\\n    }\\n    connectedCallback() {\\n        this.ionRouteDataChanged.emit();\\n    }\\n    static get watchers() { return {\\n        \\\"url\\\": [\\\"onUpdate\\\"],\\n        \\\"component\\\": [\\\"onUpdate\\\"],\\n        \\\"componentProps\\\": [\\\"onComponentProps\\\"]\\n    }; }\\n};\\n\\nconst RouteRedirect = class {\\n    constructor(hostRef) {\\n        registerInstance(this, hostRef);\\n        this.ionRouteRedirectChanged = createEvent(this, \\\"ionRouteRedirectChanged\\\", 7);\\n    }\\n    propDidChange() {\\n        this.ionRouteRedirectChanged.emit();\\n    }\\n    connectedCallback() {\\n        this.ionRouteRedirectChanged.emit();\\n    }\\n    static get watchers() { return {\\n        \\\"from\\\": [\\\"propDidChange\\\"],\\n        \\\"to\\\": [\\\"propDidChange\\\"]\\n    }; }\\n};\\n\\nconst ROUTER_INTENT_NONE = 'root';\\r\\nconst ROUTER_INTENT_FORWARD = 'forward';\\r\\nconst ROUTER_INTENT_BACK = 'back';\\n\\nconst generatePath = (segments) => {\\r\\n    const path = segments\\r\\n        .filter(s => s.length > 0)\\r\\n        .join('/');\\r\\n    return '/' + path;\\r\\n};\\r\\nconst chainToPath = (chain) => {\\r\\n    const path = [];\\r\\n    for (const route of chain) {\\r\\n        for (const segment of route.path) {\\r\\n            if (segment[0] === ':') {\\r\\n                const param = route.params && route.params[segment.slice(1)];\\r\\n                if (!param) {\\r\\n                    return null;\\r\\n                }\\r\\n                path.push(param);\\r\\n            }\\r\\n            else if (segment !== '') {\\r\\n                path.push(segment);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    return path;\\r\\n};\\r\\nconst writePath = (history, root, useHash, path, direction, state) => {\\r\\n    let url = generatePath([\\r\\n        ...parsePath(root),\\r\\n        ...path\\r\\n    ]);\\r\\n    if (useHash) {\\r\\n        url = '#' + url;\\r\\n    }\\r\\n    if (direction === ROUTER_INTENT_FORWARD) {\\r\\n        history.pushState(state, '', url);\\r\\n    }\\r\\n    else {\\r\\n        history.replaceState(state, '', url);\\r\\n    }\\r\\n};\\r\\nconst removePrefix = (prefix, path) => {\\r\\n    if (prefix.length > path.length) {\\r\\n        return null;\\r\\n    }\\r\\n    if (prefix.length <= 1 && prefix[0] === '') {\\r\\n        return path;\\r\\n    }\\r\\n    for (let i = 0; i < prefix.length; i++) {\\r\\n        if (prefix[i].length > 0 && prefix[i] !== path[i]) {\\r\\n            return null;\\r\\n        }\\r\\n    }\\r\\n    if (path.length === prefix.length) {\\r\\n        return [''];\\r\\n    }\\r\\n    return path.slice(prefix.length);\\r\\n};\\r\\nconst readPath = (loc, root, useHash) => {\\r\\n    let pathname = loc.pathname;\\r\\n    if (useHash) {\\r\\n        const hash = loc.hash;\\r\\n        pathname = (hash[0] === '#')\\r\\n            ? hash.slice(1)\\r\\n            : '';\\r\\n    }\\r\\n    const prefix = parsePath(root);\\r\\n    const path = parsePath(pathname);\\r\\n    return removePrefix(prefix, path);\\r\\n};\\r\\nconst parsePath = (path) => {\\r\\n    if (path == null) {\\r\\n        return [''];\\r\\n    }\\r\\n    const segments = path.split('/')\\r\\n        .map(s => s.trim())\\r\\n        .filter(s => s.length > 0);\\r\\n    if (segments.length === 0) {\\r\\n        return [''];\\r\\n    }\\r\\n    else {\\r\\n        return segments;\\r\\n    }\\r\\n};\\n\\nconst printRoutes = (routes) => {\\r\\n    console.group(`[ion-core] ROUTES[${routes.length}]`);\\r\\n    for (const chain of routes) {\\r\\n        const path = [];\\r\\n        chain.forEach(r => path.push(...r.path));\\r\\n        const ids = chain.map(r => r.id);\\r\\n        console.debug(`%c ${generatePath(path)}`, 'font-weight: bold; padding-left: 20px', '=>\\\\t', `(${ids.join(', ')})`);\\r\\n    }\\r\\n    console.groupEnd();\\r\\n};\\r\\nconst printRedirects = (redirects) => {\\r\\n    console.group(`[ion-core] REDIRECTS[${redirects.length}]`);\\r\\n    for (const redirect of redirects) {\\r\\n        if (redirect.to) {\\r\\n            console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to)}`, 'font-weight: bold');\\r\\n        }\\r\\n    }\\r\\n    console.groupEnd();\\r\\n};\\n\\nconst writeNavState = async (root, chain, direction, index, changed = false) => {\\r\\n    try {\\r\\n        // find next navigation outlet in the DOM\\r\\n        const outlet = searchNavNode(root);\\r\\n        // make sure we can continue interacting the DOM, otherwise abort\\r\\n        if (index >= chain.length || !outlet) {\\r\\n            return changed;\\r\\n        }\\r\\n        await outlet.componentOnReady();\\r\\n        const route = chain[index];\\r\\n        const result = await outlet.setRouteId(route.id, route.params, direction);\\r\\n        // if the outlet changed the page, reset navigation to neutral (no direction)\\r\\n        // this means nested outlets will not animate\\r\\n        if (result.changed) {\\r\\n            direction = ROUTER_INTENT_NONE;\\r\\n            changed = true;\\r\\n        }\\r\\n        // recursively set nested outlets\\r\\n        changed = await writeNavState(result.element, chain, direction, index + 1, changed);\\r\\n        // once all nested outlets are visible let's make the parent visible too,\\r\\n        // using markVisible prevents flickering\\r\\n        if (result.markVisible) {\\r\\n            await result.markVisible();\\r\\n        }\\r\\n        return changed;\\r\\n    }\\r\\n    catch (e) {\\r\\n        console.error(e);\\r\\n        return false;\\r\\n    }\\r\\n};\\r\\nconst readNavState = async (root) => {\\r\\n    const ids = [];\\r\\n    let outlet;\\r\\n    let node = root;\\r\\n    // tslint:disable-next-line:no-constant-condition\\r\\n    while (true) {\\r\\n        outlet = searchNavNode(node);\\r\\n        if (outlet) {\\r\\n            const id = await outlet.getRouteId();\\r\\n            if (id) {\\r\\n                node = id.element;\\r\\n                id.element = undefined;\\r\\n                ids.push(id);\\r\\n            }\\r\\n            else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n    return { ids, outlet };\\r\\n};\\r\\nconst waitUntilNavNode = () => {\\r\\n    if (searchNavNode(document.body)) {\\r\\n        return Promise.resolve();\\r\\n    }\\r\\n    return new Promise(resolve => {\\r\\n        window.addEventListener('ionNavWillLoad', resolve, { once: true });\\r\\n    });\\r\\n};\\r\\nconst QUERY = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';\\r\\nconst searchNavNode = (root) => {\\r\\n    if (!root) {\\r\\n        return undefined;\\r\\n    }\\r\\n    if (root.matches(QUERY)) {\\r\\n        return root;\\r\\n    }\\r\\n    const outlet = root.querySelector(QUERY);\\r\\n    return outlet ? outlet : undefined;\\r\\n};\\n\\nconst matchesRedirect = (input, route) => {\\r\\n    const { from, to } = route;\\r\\n    if (to === undefined) {\\r\\n        return false;\\r\\n    }\\r\\n    if (from.length > input.length) {\\r\\n        return false;\\r\\n    }\\r\\n    for (let i = 0; i < from.length; i++) {\\r\\n        const expected = from[i];\\r\\n        if (expected === '*') {\\r\\n            return true;\\r\\n        }\\r\\n        if (expected !== input[i]) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    return from.length === input.length;\\r\\n};\\r\\nconst routeRedirect = (path, routes) => {\\r\\n    return routes.find(route => matchesRedirect(path, route));\\r\\n};\\r\\nconst matchesIDs = (ids, chain) => {\\r\\n    const len = Math.min(ids.length, chain.length);\\r\\n    let i = 0;\\r\\n    for (; i < len; i++) {\\r\\n        if (ids[i].toLowerCase() !== chain[i].id) {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n    return i;\\r\\n};\\r\\nconst matchesPath = (inputPath, chain) => {\\r\\n    const segments = new RouterSegments(inputPath);\\r\\n    let matchesDefault = false;\\r\\n    let allparams;\\r\\n    for (let i = 0; i < chain.length; i++) {\\r\\n        const path = chain[i].path;\\r\\n        if (path[0] === '') {\\r\\n            matchesDefault = true;\\r\\n        }\\r\\n        else {\\r\\n            for (const segment of path) {\\r\\n                const data = segments.next();\\r\\n                // data param\\r\\n                if (segment[0] === ':') {\\r\\n                    if (data === '') {\\r\\n                        return null;\\r\\n                    }\\r\\n                    allparams = allparams || [];\\r\\n                    const params = allparams[i] || (allparams[i] = {});\\r\\n                    params[segment.slice(1)] = data;\\r\\n                }\\r\\n                else if (data !== segment) {\\r\\n                    return null;\\r\\n                }\\r\\n            }\\r\\n            matchesDefault = false;\\r\\n        }\\r\\n    }\\r\\n    const matches = (matchesDefault)\\r\\n        ? matchesDefault === (segments.next() === '')\\r\\n        : true;\\r\\n    if (!matches) {\\r\\n        return null;\\r\\n    }\\r\\n    if (allparams) {\\r\\n        return chain.map((route, i) => ({\\r\\n            id: route.id,\\r\\n            path: route.path,\\r\\n            params: mergeParams(route.params, allparams[i])\\r\\n        }));\\r\\n    }\\r\\n    return chain;\\r\\n};\\r\\nconst mergeParams = (a, b) => {\\r\\n    if (!a && b) {\\r\\n        return b;\\r\\n    }\\r\\n    else if (a && !b) {\\r\\n        return a;\\r\\n    }\\r\\n    else if (a && b) {\\r\\n        return Object.assign({}, a, b);\\r\\n    }\\r\\n    return undefined;\\r\\n};\\r\\nconst routerIDsToChain = (ids, chains) => {\\r\\n    let match = null;\\r\\n    let maxMatches = 0;\\r\\n    const plainIDs = ids.map(i => i.id);\\r\\n    for (const chain of chains) {\\r\\n        const score = matchesIDs(plainIDs, chain);\\r\\n        if (score > maxMatches) {\\r\\n            match = chain;\\r\\n            maxMatches = score;\\r\\n        }\\r\\n    }\\r\\n    if (match) {\\r\\n        return match.map((route, i) => ({\\r\\n            id: route.id,\\r\\n            path: route.path,\\r\\n            params: mergeParams(route.params, ids[i] && ids[i].params)\\r\\n        }));\\r\\n    }\\r\\n    return null;\\r\\n};\\r\\nconst routerPathToChain = (path, chains) => {\\r\\n    let match = null;\\r\\n    let matches = 0;\\r\\n    for (const chain of chains) {\\r\\n        const matchedChain = matchesPath(path, chain);\\r\\n        if (matchedChain !== null) {\\r\\n            const score = computePriority(matchedChain);\\r\\n            if (score > matches) {\\r\\n                matches = score;\\r\\n                match = matchedChain;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    return match;\\r\\n};\\r\\nconst computePriority = (chain) => {\\r\\n    let score = 1;\\r\\n    let level = 1;\\r\\n    for (const route of chain) {\\r\\n        for (const path of route.path) {\\r\\n            if (path[0] === ':') {\\r\\n                score += Math.pow(1, level);\\r\\n            }\\r\\n            else if (path !== '') {\\r\\n                score += Math.pow(2, level);\\r\\n            }\\r\\n            level++;\\r\\n        }\\r\\n    }\\r\\n    return score;\\r\\n};\\r\\nclass RouterSegments {\\r\\n    constructor(path) {\\r\\n        this.path = path.slice();\\r\\n    }\\r\\n    next() {\\r\\n        if (this.path.length > 0) {\\r\\n            return this.path.shift();\\r\\n        }\\r\\n        return '';\\r\\n    }\\r\\n}\\n\\nconst readRedirects = (root) => {\\r\\n    return Array.from(root.children)\\r\\n        .filter(el => el.tagName === 'ION-ROUTE-REDIRECT')\\r\\n        .map(el => {\\r\\n        const to = readProp(el, 'to');\\r\\n        return {\\r\\n            from: parsePath(readProp(el, 'from')),\\r\\n            to: to == null ? undefined : parsePath(to),\\r\\n        };\\r\\n    });\\r\\n};\\r\\nconst readRoutes = (root) => {\\r\\n    return flattenRouterTree(readRouteNodes(root));\\r\\n};\\r\\nconst readRouteNodes = (root, node = root) => {\\r\\n    return Array.from(node.children)\\r\\n        .filter(el => el.tagName === 'ION-ROUTE' && el.component)\\r\\n        .map(el => {\\r\\n        const component = readProp(el, 'component');\\r\\n        if (component == null) {\\r\\n            throw new Error('component missing in ion-route');\\r\\n        }\\r\\n        return {\\r\\n            path: parsePath(readProp(el, 'url')),\\r\\n            id: component.toLowerCase(),\\r\\n            params: el.componentProps,\\r\\n            children: readRouteNodes(root, el)\\r\\n        };\\r\\n    });\\r\\n};\\r\\nconst readProp = (el, prop) => {\\r\\n    if (prop in el) {\\r\\n        return el[prop];\\r\\n    }\\r\\n    if (el.hasAttribute(prop)) {\\r\\n        return el.getAttribute(prop);\\r\\n    }\\r\\n    return null;\\r\\n};\\r\\nconst flattenRouterTree = (nodes) => {\\r\\n    const routes = [];\\r\\n    for (const node of nodes) {\\r\\n        flattenNode([], routes, node);\\r\\n    }\\r\\n    return routes;\\r\\n};\\r\\nconst flattenNode = (chain, routes, node) => {\\r\\n    const s = chain.slice();\\r\\n    s.push({\\r\\n        id: node.id,\\r\\n        path: node.path,\\r\\n        params: node.params\\r\\n    });\\r\\n    if (node.children.length === 0) {\\r\\n        routes.push(s);\\r\\n        return;\\r\\n    }\\r\\n    for (const sub of node.children) {\\r\\n        flattenNode(s, routes, sub);\\r\\n    }\\r\\n};\\n\\nconst Router = class {\\n    constructor(hostRef) {\\n        registerInstance(this, hostRef);\\n        this.previousPath = null;\\n        this.busy = false;\\n        this.state = 0;\\n        this.lastState = 0;\\n        /**\\n         * By default `ion-router` will match the routes at the root path (\\\"/\\\").\\n         * That can be changed when\\n         *\\n         */\\n        this.root = '/';\\n        /**\\n         * The router can work in two \\\"modes\\\":\\n         * - With hash: `/index.html#/path/to/page`\\n         * - Without hash: `/path/to/page`\\n         *\\n         * Using one or another might depend in the requirements of your app and/or where it's deployed.\\n         *\\n         * Usually \\\"hash-less\\\" navigation works better for SEO and it's more user friendly too, but it might\\n         * requires additional server-side configuration in order to properly work.\\n         *\\n         * On the otherside hash-navigation is much easier to deploy, it even works over the file protocol.\\n         *\\n         * By default, this property is `true`, change to `false` to allow hash-less URLs.\\n         */\\n        this.useHash = true;\\n        this.ionRouteWillChange = createEvent(this, \\\"ionRouteWillChange\\\", 7);\\n        this.ionRouteDidChange = createEvent(this, \\\"ionRouteDidChange\\\", 7);\\n    }\\n    async componentWillLoad() {\\n        console.debug('[ion-router] router will load');\\n        await waitUntilNavNode();\\n        console.debug('[ion-router] found nav');\\n        await this.onRoutesChanged();\\n    }\\n    componentDidLoad() {\\n        window.addEventListener('ionRouteRedirectChanged', debounce(this.onRedirectChanged.bind(this), 10));\\n        window.addEventListener('ionRouteDataChanged', debounce(this.onRoutesChanged.bind(this), 100));\\n    }\\n    onPopState() {\\n        const direction = this.historyDirection();\\n        const path = this.getPath();\\n        console.debug('[ion-router] URL changed -> update nav', path, direction);\\n        return this.writeNavStateRoot(path, direction);\\n    }\\n    onBackButton(ev) {\\n        ev.detail.register(0, () => this.back());\\n    }\\n    /**\\n     * Navigate to the specified URL.\\n     *\\n     * @param url The url to navigate to.\\n     * @param direction The direction of the animation. Defaults to `\\\"forward\\\"`.\\n     */\\n    push(url, direction = 'forward') {\\n        if (url.startsWith('.')) {\\n            url = (new URL(url, window.location.href)).pathname;\\n        }\\n        console.debug('[ion-router] URL pushed -> updating nav', url, direction);\\n        const path = parsePath(url);\\n        this.setPath(path, direction);\\n        return this.writeNavStateRoot(path, direction);\\n    }\\n    /**\\n     * Go back to previous page in the window.history.\\n     */\\n    back() {\\n        window.history.back();\\n        return Promise.resolve(this.waitPromise);\\n    }\\n    /** @internal */\\n    async printDebug() {\\n        console.debug('CURRENT PATH', this.getPath());\\n        console.debug('PREVIOUS PATH', this.previousPath);\\n        printRoutes(readRoutes(this.el));\\n        printRedirects(readRedirects(this.el));\\n    }\\n    /** @internal */\\n    async navChanged(direction) {\\n        if (this.busy) {\\n            console.warn('[ion-router] router is busy, navChanged was cancelled');\\n            return false;\\n        }\\n        const { ids, outlet } = await readNavState(window.document.body);\\n        const routes = readRoutes(this.el);\\n        const chain = routerIDsToChain(ids, routes);\\n        if (!chain) {\\n            console.warn('[ion-router] no matching URL for ', ids.map(i => i.id));\\n            return false;\\n        }\\n        const path = chainToPath(chain);\\n        if (!path) {\\n            console.warn('[ion-router] router could not match path because some required param is missing');\\n            return false;\\n        }\\n        console.debug('[ion-router] nav changed -> update URL', ids, path);\\n        this.setPath(path, direction);\\n        await this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, path, null, ids.length);\\n        return true;\\n    }\\n    onRedirectChanged() {\\n        const path = this.getPath();\\n        if (path && routeRedirect(path, readRedirects(this.el))) {\\n            this.writeNavStateRoot(path, ROUTER_INTENT_NONE);\\n        }\\n    }\\n    onRoutesChanged() {\\n        return this.writeNavStateRoot(this.getPath(), ROUTER_INTENT_NONE);\\n    }\\n    historyDirection() {\\n        const win = window;\\n        if (win.history.state === null) {\\n            this.state++;\\n            win.history.replaceState(this.state, win.document.title, win.document.location && win.document.location.href);\\n        }\\n        const state = win.history.state;\\n        const lastState = this.lastState;\\n        this.lastState = state;\\n        if (state > lastState) {\\n            return ROUTER_INTENT_FORWARD;\\n        }\\n        else if (state < lastState) {\\n            return ROUTER_INTENT_BACK;\\n        }\\n        else {\\n            return ROUTER_INTENT_NONE;\\n        }\\n    }\\n    async writeNavStateRoot(path, direction) {\\n        if (!path) {\\n            console.error('[ion-router] URL is not part of the routing set');\\n            return false;\\n        }\\n        // lookup redirect rule\\n        const redirects = readRedirects(this.el);\\n        const redirect = routeRedirect(path, redirects);\\n        let redirectFrom = null;\\n        if (redirect) {\\n            this.setPath(redirect.to, direction);\\n            redirectFrom = redirect.from;\\n            path = redirect.to;\\n        }\\n        // lookup route chain\\n        const routes = readRoutes(this.el);\\n        const chain = routerPathToChain(path, routes);\\n        if (!chain) {\\n            console.error('[ion-router] the path does not match any route');\\n            return false;\\n        }\\n        // write DOM give\\n        return this.safeWriteNavState(document.body, chain, direction, path, redirectFrom);\\n    }\\n    async safeWriteNavState(node, chain, direction, path, redirectFrom, index = 0) {\\n        const unlock = await this.lock();\\n        let changed = false;\\n        try {\\n            changed = await this.writeNavState(node, chain, direction, path, redirectFrom, index);\\n        }\\n        catch (e) {\\n            console.error(e);\\n        }\\n        unlock();\\n        return changed;\\n    }\\n    async lock() {\\n        const p = this.waitPromise;\\n        let resolve;\\n        this.waitPromise = new Promise(r => resolve = r);\\n        if (p !== undefined) {\\n            await p;\\n        }\\n        return resolve;\\n    }\\n    async writeNavState(node, chain, direction, path, redirectFrom, index = 0) {\\n        if (this.busy) {\\n            console.warn('[ion-router] router is busy, transition was cancelled');\\n            return false;\\n        }\\n        this.busy = true;\\n        // generate route event and emit will change\\n        const routeEvent = this.routeChangeEvent(path, redirectFrom);\\n        if (routeEvent) {\\n            this.ionRouteWillChange.emit(routeEvent);\\n        }\\n        const changed = await writeNavState(node, chain, direction, index);\\n        this.busy = false;\\n        if (changed) {\\n            console.debug('[ion-router] route changed', path);\\n        }\\n        // emit did change\\n        if (routeEvent) {\\n            this.ionRouteDidChange.emit(routeEvent);\\n        }\\n        return changed;\\n    }\\n    setPath(path, direction) {\\n        this.state++;\\n        writePath(window.history, this.root, this.useHash, path, direction, this.state);\\n    }\\n    getPath() {\\n        return readPath(window.location, this.root, this.useHash);\\n    }\\n    routeChangeEvent(path, redirectFromPath) {\\n        const from = this.previousPath;\\n        const to = generatePath(path);\\n        this.previousPath = to;\\n        if (to === from) {\\n            return null;\\n        }\\n        const redirectedFrom = redirectFromPath ? generatePath(redirectFromPath) : null;\\n        return {\\n            from,\\n            redirectedFrom,\\n            to,\\n        };\\n    }\\n    get el() { return getElement(this); }\\n};\\n\\nconst RouterLink = class {\\n    constructor(hostRef) {\\n        registerInstance(this, hostRef);\\n        /**\\n         * When using a router, it specifies the transition direction when navigating to\\n         * another page using `href`.\\n         */\\n        this.routerDirection = 'forward';\\n        this.onClick = (ev) => {\\n            openURL(this.href, ev, this.routerDirection);\\n        };\\n    }\\n    render() {\\n        const mode = getIonMode(this);\\n        const attrs = {\\n            href: this.href,\\n            rel: this.rel,\\n            target: this.target\\n        };\\n        return (h(Host, { onClick: this.onClick, class: Object.assign({}, createColorClasses(this.color), { [mode]: true, 'ion-activatable': true }) }, h(\\\"a\\\", Object.assign({}, attrs), h(\\\"slot\\\", null))));\\n    }\\n    static get style() { return \\\":host{--background:transparent;--color:var(--ion-color-primary,#3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}\\\"; }\\n};\\n\\nexport { Route as ion_route, RouteRedirect as ion_route_redirect, Router as ion_router, RouterLink as ion_router_link };\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{k5eQ:function(t,e,o){\"use strict\";o.r(e),o.d(e,\"ion_route\",(function(){return s})),o.d(e,\"ion_route_redirect\",(function(){return a})),o.d(e,\"ion_router\",(function(){return j})),o.d(e,\"ion_router_link\",(function(){return k}));var n=o(\"MTfx\"),r=(o(\"pcH8\"),o(\"pyhm\")),i=o(\"9Xoc\");const s=class{constructor(t){Object(n.l)(this,t),this.url=\"\",this.ionRouteDataChanged=Object(n.d)(this,\"ionRouteDataChanged\",7)}onUpdate(t){this.ionRouteDataChanged.emit(t)}onComponentProps(t,e){if(t===e)return;const o=t?Object.keys(t):[],n=e?Object.keys(e):[];if(o.length===n.length){for(const r of o)if(t[r]!==e[r])return void this.onUpdate(t)}else this.onUpdate(t)}connectedCallback(){this.ionRouteDataChanged.emit()}static get watchers(){return{url:[\"onUpdate\"],component:[\"onUpdate\"],componentProps:[\"onComponentProps\"]}}},a=class{constructor(t){Object(n.l)(this,t),this.ionRouteRedirectChanged=Object(n.d)(this,\"ionRouteRedirectChanged\",7)}propDidChange(){this.ionRouteRedirectChanged.emit()}connectedCallback(){this.ionRouteRedirectChanged.emit()}static get watchers(){return{from:[\"propDidChange\"],to:[\"propDidChange\"]}}},h=t=>\"/\"+t.filter(t=>t.length>0).join(\"/\"),c=t=>{if(null==t)return[\"\"];const e=t.split(\"/\").map(t=>t.trim()).filter(t=>t.length>0);return 0===e.length?[\"\"]:e},l=async(t,e,o,n,r=!1)=>{try{const i=d(t);if(n>=e.length||!i)return r;await i.componentOnReady();const s=e[n],a=await i.setRouteId(s.id,s.params,o);return a.changed&&(o=\"root\",r=!0),r=await l(a.element,e,o,n+1,r),a.markVisible&&await a.markVisible(),r}catch(i){return console.error(i),!1}},u=\":not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet\",d=t=>{if(t)return t.matches(u)?t:t.querySelector(u)||void 0},f=(t,e)=>e.find(e=>((t,e)=>{const{from:o,to:n}=e;if(void 0===n)return!1;if(o.length>t.length)return!1;for(let r=0;r<o.length;r++){const e=o[r];if(\"*\"===e)return!0;if(e!==t[r])return!1}return o.length===t.length})(t,e)),g=(t,e)=>{const o=Math.min(t.length,e.length);let n=0;for(;n<o&&t[n].toLowerCase()===e[n].id;n++);return n},p=(t,e)=>{const o=new b(t);let n,r=!1;for(let i=0;i<e.length;i++){const t=e[i].path;if(\"\"===t[0])r=!0;else{for(const e of t){const t=o.next();if(\":\"===e[0]){if(\"\"===t)return null;((n=n||[])[i]||(n[i]={}))[e.slice(1)]=t}else if(t!==e)return null}r=!1}}return r&&r!==(\"\"===o.next())?null:n?e.map((t,e)=>({id:t.id,path:t.path,params:m(t.params,n[e])})):e},m=(t,e)=>!t&&e?e:t&&!e?t:t&&e?Object.assign({},t,e):void 0,w=t=>{let e=1,o=1;for(const n of t)for(const t of n.path)\":\"===t[0]?e+=Math.pow(1,o):\"\"!==t&&(e+=Math.pow(2,o)),o++;return e};class b{constructor(t){this.path=t.slice()}next(){return this.path.length>0?this.path.shift():\"\"}}const R=t=>Array.from(t.children).filter(t=>\"ION-ROUTE-REDIRECT\"===t.tagName).map(t=>{const e=C(t,\"to\");return{from:c(C(t,\"from\")),to:null==e?void 0:c(e)}}),v=t=>O(y(t)),y=(t,e=t)=>Array.from(e.children).filter(t=>\"ION-ROUTE\"===t.tagName&&t.component).map(e=>{const o=C(e,\"component\");if(null==o)throw new Error(\"component missing in ion-route\");return{path:c(C(e,\"url\")),id:o.toLowerCase(),params:e.componentProps,children:y(t,e)}}),C=(t,e)=>e in t?t[e]:t.hasAttribute(e)?t.getAttribute(e):null,O=t=>{const e=[];for(const o of t)P([],e,o);return e},P=(t,e,o)=>{const n=t.slice();if(n.push({id:o.id,path:o.path,params:o.params}),0!==o.children.length)for(const r of o.children)P(n,e,r);else e.push(n)},j=class{constructor(t){Object(n.l)(this,t),this.previousPath=null,this.busy=!1,this.state=0,this.lastState=0,this.root=\"/\",this.useHash=!0,this.ionRouteWillChange=Object(n.d)(this,\"ionRouteWillChange\",7),this.ionRouteDidChange=Object(n.d)(this,\"ionRouteDidChange\",7)}async componentWillLoad(){console.debug(\"[ion-router] router will load\"),await(()=>d(document.body)?Promise.resolve():new Promise(t=>{window.addEventListener(\"ionNavWillLoad\",t,{once:!0})}))(),console.debug(\"[ion-router] found nav\"),await this.onRoutesChanged()}componentDidLoad(){window.addEventListener(\"ionRouteRedirectChanged\",Object(i.e)(this.onRedirectChanged.bind(this),10)),window.addEventListener(\"ionRouteDataChanged\",Object(i.e)(this.onRoutesChanged.bind(this),100))}onPopState(){const t=this.historyDirection(),e=this.getPath();return console.debug(\"[ion-router] URL changed -> update nav\",e,t),this.writeNavStateRoot(e,t)}onBackButton(t){t.detail.register(0,()=>this.back())}push(t,e=\"forward\"){t.startsWith(\".\")&&(t=new URL(t,window.location.href).pathname),console.debug(\"[ion-router] URL pushed -> updating nav\",t,e);const o=c(t);return this.setPath(o,e),this.writeNavStateRoot(o,e)}back(){return window.history.back(),Promise.resolve(this.waitPromise)}async printDebug(){console.debug(\"CURRENT PATH\",this.getPath()),console.debug(\"PREVIOUS PATH\",this.previousPath),(t=>{console.group(`[ion-core] ROUTES[${t.length}]`);for(const e of t){const t=[];e.forEach(e=>t.push(...e.path));const o=e.map(t=>t.id);console.debug(`%c ${h(t)}`,\"font-weight: bold; padding-left: 20px\",\"=>\\t\",`(${o.join(\", \")})`)}console.groupEnd()})(v(this.el)),(t=>{console.group(`[ion-core] REDIRECTS[${t.length}]`);for(const e of t)e.to&&console.debug(\"FROM: \",`$c ${h(e.from)}`,\"font-weight: bold\",\" TO: \",`$c ${h(e.to)}`,\"font-weight: bold\");console.groupEnd()})(R(this.el))}async navChanged(t){if(this.busy)return console.warn(\"[ion-router] router is busy, navChanged was cancelled\"),!1;const{ids:e,outlet:o}=await(async t=>{const e=[];let o,n=window.document.body;for(;o=d(n);){const t=await o.getRouteId();if(!t)break;n=t.element,t.element=void 0,e.push(t)}return{ids:e,outlet:o}})(),n=((t,e)=>{let o=null,n=0;const r=t.map(t=>t.id);for(const i of e){const t=g(r,i);t>n&&(o=i,n=t)}return o?o.map((e,o)=>({id:e.id,path:e.path,params:m(e.params,t[o]&&t[o].params)})):null})(e,v(this.el));if(!n)return console.warn(\"[ion-router] no matching URL for \",e.map(t=>t.id)),!1;const r=(t=>{const e=[];for(const o of t)for(const t of o.path)if(\":\"===t[0]){const n=o.params&&o.params[t.slice(1)];if(!n)return null;e.push(n)}else\"\"!==t&&e.push(t);return e})(n);return r?(console.debug(\"[ion-router] nav changed -> update URL\",e,r),this.setPath(r,t),await this.safeWriteNavState(o,n,\"root\",r,null,e.length),!0):(console.warn(\"[ion-router] router could not match path because some required param is missing\"),!1)}onRedirectChanged(){const t=this.getPath();t&&f(t,R(this.el))&&this.writeNavStateRoot(t,\"root\")}onRoutesChanged(){return this.writeNavStateRoot(this.getPath(),\"root\")}historyDirection(){const t=window;null===t.history.state&&(this.state++,t.history.replaceState(this.state,t.document.title,t.document.location&&t.document.location.href));const e=t.history.state,o=this.lastState;return this.lastState=e,e>o?\"forward\":e<o?\"back\":\"root\"}async writeNavStateRoot(t,e){if(!t)return console.error(\"[ion-router] URL is not part of the routing set\"),!1;const o=R(this.el),n=f(t,o);let r=null;n&&(this.setPath(n.to,e),r=n.from,t=n.to);const i=((t,e)=>{let o=null,n=0;for(const r of e){const e=p(t,r);if(null!==e){const t=w(e);t>n&&(n=t,o=e)}}return o})(t,v(this.el));return i?this.safeWriteNavState(document.body,i,e,t,r):(console.error(\"[ion-router] the path does not match any route\"),!1)}async safeWriteNavState(t,e,o,n,r,i=0){const s=await this.lock();let a=!1;try{a=await this.writeNavState(t,e,o,n,r,i)}catch(h){console.error(h)}return s(),a}async lock(){const t=this.waitPromise;let e;return this.waitPromise=new Promise(t=>e=t),void 0!==t&&await t,e}async writeNavState(t,e,o,n,r,i=0){if(this.busy)return console.warn(\"[ion-router] router is busy, transition was cancelled\"),!1;this.busy=!0;const s=this.routeChangeEvent(n,r);s&&this.ionRouteWillChange.emit(s);const a=await l(t,e,o,i);return this.busy=!1,a&&console.debug(\"[ion-router] route changed\",n),s&&this.ionRouteDidChange.emit(s),a}setPath(t,e){this.state++,((t,e,o,n,r,i)=>{let s=h([...c(this.root),...n]);o&&(s=\"#\"+s),\"forward\"===r?t.pushState(i,\"\",s):t.replaceState(i,\"\",s)})(window.history,0,this.useHash,t,e,this.state)}getPath(){return((t,e,o)=>{let n=t.pathname;if(this.useHash){const e=t.hash;n=\"#\"===e[0]?e.slice(1):\"\"}return((t,e)=>{if(t.length>e.length)return null;if(t.length<=1&&\"\"===t[0])return e;for(let o=0;o<t.length;o++)if(t[o].length>0&&t[o]!==e[o])return null;return e.length===t.length?[\"\"]:e.slice(t.length)})(c(e),c(n))})(window.location,this.root)}routeChangeEvent(t,e){const o=this.previousPath,n=h(t);return this.previousPath=n,n===o?null:{from:o,redirectedFrom:e?h(e):null,to:n}}get el(){return Object(n.f)(this)}},k=class{constructor(t){Object(n.l)(this,t),this.routerDirection=\"forward\",this.onClick=t=>{Object(r.d)(this.href,t,this.routerDirection)}}render(){const t=Object(n.e)(this),e={href:this.href,rel:this.rel,target:this.target};return Object(n.i)(n.a,{onClick:this.onClick,class:Object.assign({},Object(r.a)(this.color),{[t]:!0,\"ion-activatable\":!0})},Object(n.i)(\"a\",Object.assign({},e),Object(n.i)(\"slot\",null)))}static get style(){return\":host{--background:transparent;--color:var(--ion-color-primary,#3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}\"}}}}]);","extractedComments":[]}