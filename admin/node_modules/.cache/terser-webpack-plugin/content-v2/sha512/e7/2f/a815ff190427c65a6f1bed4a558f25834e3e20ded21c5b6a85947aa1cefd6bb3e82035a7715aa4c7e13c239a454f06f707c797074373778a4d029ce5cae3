{"map":"{\"version\":3,\"sources\":[\"/home/angeloacr/Proyectos/Tuk/ionic-taxi-4/admin/node_modules/@ionic/core/dist/esm/input-shims-7b87c414.js.pre-build-optimizer.js\"],\"names\":[\"__webpack_require__\",\"r\",\"__webpack_exports__\",\"d\",\"startInputShims\",\"_helpers_c90aaa66_js__WEBPACK_IMPORTED_MODULE_0__\",\"cloneMap\",\"WeakMap\",\"relocateInput\",\"componentEl\",\"inputEl\",\"shouldRelocate\",\"inputRelativeY\",\"has\",\"addClone\",\"removeClone\",\"isFocused\",\"input\",\"getRootNode\",\"activeElement\",\"parentEl\",\"parentNode\",\"clonedEl\",\"cloneNode\",\"classList\",\"add\",\"tabIndex\",\"appendChild\",\"set\",\"tx\",\"ownerDocument\",\"dir\",\"style\",\"pointerEvents\",\"transform\",\"clone\",\"get\",\"delete\",\"remove\",\"SKIP_SELECTOR\",\"setScrollPadding\",\"keyboardHeight\",\"tagName\",\"parentElement\",\"el\",\"closest\",\"timer\",\"clearTimeout\",\"setProperty\",\"setTimeout\",\"config\",\"doc\",\"document\",\"getNumber\",\"scrollAssist\",\"getBoolean\",\"hideCaret\",\"inputBlurring\",\"scrollPadding\",\"inputs\",\"Array\",\"from\",\"querySelectorAll\",\"hideCaretMap\",\"scrollAssistMap\",\"registerInput\",\"shadowRoot\",\"querySelector\",\"scrollEl\",\"rmFn\",\"scrollHideCaret\",\"shouldHideCaret\",\"onBlur\",\"showCaret\",\"addEventListener\",\"removeEventListener\",\"enableHideCaretOnScroll\",\"contentEl\",\"coord\",\"touchStart\",\"ev\",\"Object\",\"touchEnd\",\"endCoord\",\"threshold\",\"startCoord\",\"deltaX\",\"x\",\"deltaY\",\"y\",\"hasPointerMoved\",\"preventDefault\",\"stopPropagation\",\"scrollData\",\"inputRect\",\"contentRect\",\"platformHeight\",\"inputTop\",\"top\",\"inputBottom\",\"bottom\",\"visibleAreaTop\",\"safeAreaTop\",\"distanceToBottom\",\"Math\",\"min\",\"distanceToTop\",\"desiredScrollAmount\",\"round\",\"scrollAmount\",\"distance\",\"abs\",\"scrollDuration\",\"max\",\"inputSafeY\",\"calcScrollData\",\"getBoundingClientRect\",\"defaultView\",\"innerHeight\",\"getScrollData\",\"focus\",\"scrollByPoint\",\"then\",\"jsSetFocus\",\"enableScrollAssist\",\"focused\",\"didScroll\",\"active\",\"matches\",\"tapped\",\"target\",\"blur\",\"enableInputBlurring\",\"enableScrollPadding\",\"detail\",\"fn\",\"unregisterInput\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { p as pointerCoord } from './helpers-c90aaa66.js';\\n\\nconst cloneMap = new WeakMap();\\r\\nconst relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0) => {\\r\\n    if (cloneMap.has(componentEl) === shouldRelocate) {\\r\\n        return;\\r\\n    }\\r\\n    if (shouldRelocate) {\\r\\n        addClone(componentEl, inputEl, inputRelativeY);\\r\\n    }\\r\\n    else {\\r\\n        removeClone(componentEl, inputEl);\\r\\n    }\\r\\n};\\r\\nconst isFocused = (input) => {\\r\\n    return input === input.getRootNode().activeElement;\\r\\n};\\r\\nconst addClone = (componentEl, inputEl, inputRelativeY) => {\\r\\n    // this allows for the actual input to receive the focus from\\r\\n    // the user's touch event, but before it receives focus, it\\r\\n    // moves the actual input to a location that will not screw\\r\\n    // up the app's layout, and does not allow the native browser\\r\\n    // to attempt to scroll the input into place (messing up headers/footers)\\r\\n    // the cloned input fills the area of where native input should be\\r\\n    // while the native input fakes out the browser by relocating itself\\r\\n    // before it receives the actual focus event\\r\\n    // We hide the focused input (with the visible caret) invisible by making it scale(0),\\r\\n    const parentEl = inputEl.parentNode;\\r\\n    // DOM WRITES\\r\\n    const clonedEl = inputEl.cloneNode(false);\\r\\n    clonedEl.classList.add('cloned-input');\\r\\n    clonedEl.tabIndex = -1;\\r\\n    parentEl.appendChild(clonedEl);\\r\\n    cloneMap.set(componentEl, clonedEl);\\r\\n    const doc = componentEl.ownerDocument;\\r\\n    const tx = doc.dir === 'rtl' ? 9999 : -9999;\\r\\n    componentEl.style.pointerEvents = 'none';\\r\\n    inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;\\r\\n};\\r\\nconst removeClone = (componentEl, inputEl) => {\\r\\n    const clone = cloneMap.get(componentEl);\\r\\n    if (clone) {\\r\\n        cloneMap.delete(componentEl);\\r\\n        clone.remove();\\r\\n    }\\r\\n    componentEl.style.pointerEvents = '';\\r\\n    inputEl.style.transform = '';\\r\\n};\\n\\nconst enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {\\r\\n    if (!scrollEl || !inputEl) {\\r\\n        return () => { return; };\\r\\n    }\\r\\n    const scrollHideCaret = (shouldHideCaret) => {\\r\\n        if (isFocused(inputEl)) {\\r\\n            relocateInput(componentEl, inputEl, shouldHideCaret);\\r\\n        }\\r\\n    };\\r\\n    const onBlur = () => relocateInput(componentEl, inputEl, false);\\r\\n    const hideCaret = () => scrollHideCaret(true);\\r\\n    const showCaret = () => scrollHideCaret(false);\\r\\n    scrollEl.addEventListener('ionScrollStart', hideCaret);\\r\\n    scrollEl.addEventListener('ionScrollEnd', showCaret);\\r\\n    inputEl.addEventListener('blur', onBlur);\\r\\n    return () => {\\r\\n        scrollEl.removeEventListener('ionScrollStart', hideCaret);\\r\\n        scrollEl.removeEventListener('ionScrollEnd', showCaret);\\r\\n        inputEl.addEventListener('ionBlur', onBlur);\\r\\n    };\\r\\n};\\n\\nconst SKIP_SELECTOR = 'input, textarea, [no-blur]';\\r\\nconst enableInputBlurring = () => {\\r\\n    let focused = true;\\r\\n    let didScroll = false;\\r\\n    const doc = document;\\r\\n    const onScroll = () => {\\r\\n        didScroll = true;\\r\\n    };\\r\\n    const onFocusin = () => {\\r\\n        focused = true;\\r\\n    };\\r\\n    const onTouchend = (ev) => {\\r\\n        // if app did scroll return early\\r\\n        if (didScroll) {\\r\\n            didScroll = false;\\r\\n            return;\\r\\n        }\\r\\n        const active = doc.activeElement;\\r\\n        if (!active) {\\r\\n            return;\\r\\n        }\\r\\n        // only blur if the active element is a text-input or a textarea\\r\\n        if (active.matches(SKIP_SELECTOR)) {\\r\\n            return;\\r\\n        }\\r\\n        // if the selected target is the active element, do not blur\\r\\n        const tapped = ev.target;\\r\\n        if (tapped === active) {\\r\\n            return;\\r\\n        }\\r\\n        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\\r\\n            return;\\r\\n        }\\r\\n        focused = false;\\r\\n        // TODO: find a better way, why 50ms?\\r\\n        setTimeout(() => {\\r\\n            if (!focused) {\\r\\n                active.blur();\\r\\n            }\\r\\n        }, 50);\\r\\n    };\\r\\n    doc.addEventListener('ionScrollStart', onScroll);\\r\\n    doc.addEventListener('focusin', onFocusin, true);\\r\\n    doc.addEventListener('touchend', onTouchend, false);\\r\\n    return () => {\\r\\n        doc.removeEventListener('ionScrollStart', onScroll, true);\\r\\n        doc.removeEventListener('focusin', onFocusin, true);\\r\\n        doc.removeEventListener('touchend', onTouchend, false);\\r\\n    };\\r\\n};\\n\\nconst SCROLL_ASSIST_SPEED = 0.3;\\r\\nconst getScrollData = (componentEl, contentEl, keyboardHeight) => {\\r\\n    const itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\\r\\n    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\\r\\n};\\r\\nconst calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {\\r\\n    // compute input's Y values relative to the body\\r\\n    const inputTop = inputRect.top;\\r\\n    const inputBottom = inputRect.bottom;\\r\\n    // compute visible area\\r\\n    const visibleAreaTop = contentRect.top;\\r\\n    const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\\r\\n    // compute safe area\\r\\n    const safeAreaTop = visibleAreaTop + 15;\\r\\n    const safeAreaBottom = visibleAreaBottom * 0.5;\\r\\n    // figure out if each edge of the input is within the safe area\\r\\n    const distanceToBottom = safeAreaBottom - inputBottom;\\r\\n    const distanceToTop = safeAreaTop - inputTop;\\r\\n    // desiredScrollAmount is the negated distance to the safe area according to our calculations.\\r\\n    const desiredScrollAmount = Math.round((distanceToBottom < 0)\\r\\n        ? -distanceToBottom\\r\\n        : (distanceToTop > 0)\\r\\n            ? -distanceToTop\\r\\n            : 0);\\r\\n    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\\r\\n    // gets focus, so make sure we don't scroll the input above the visible area\\r\\n    const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\\r\\n    const distance = Math.abs(scrollAmount);\\r\\n    const duration = distance / SCROLL_ASSIST_SPEED;\\r\\n    const scrollDuration = Math.min(400, Math.max(150, duration));\\r\\n    return {\\r\\n        scrollAmount,\\r\\n        scrollDuration,\\r\\n        scrollPadding: keyboardHeight,\\r\\n        inputSafeY: -(inputTop - safeAreaTop) + 4\\r\\n    };\\r\\n};\\n\\nconst enableScrollAssist = (componentEl, inputEl, contentEl, keyboardHeight) => {\\r\\n    let coord;\\r\\n    const touchStart = (ev) => {\\r\\n        coord = pointerCoord(ev);\\r\\n    };\\r\\n    const touchEnd = (ev) => {\\r\\n        // input cover touchend/mouseup\\r\\n        if (!coord) {\\r\\n            return;\\r\\n        }\\r\\n        // get where the touchend/mouseup ended\\r\\n        const endCoord = pointerCoord(ev);\\r\\n        // focus this input if the pointer hasn't moved XX pixels\\r\\n        // and the input doesn't already have focus\\r\\n        if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\\r\\n            ev.preventDefault();\\r\\n            ev.stopPropagation();\\r\\n            // begin the input focus process\\r\\n            jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight);\\r\\n        }\\r\\n    };\\r\\n    componentEl.addEventListener('touchstart', touchStart, true);\\r\\n    componentEl.addEventListener('touchend', touchEnd, true);\\r\\n    return () => {\\r\\n        componentEl.removeEventListener('touchstart', touchStart, true);\\r\\n        componentEl.removeEventListener('touchend', touchEnd, true);\\r\\n    };\\r\\n};\\r\\nconst jsSetFocus = (componentEl, inputEl, contentEl, keyboardHeight) => {\\r\\n    const scrollData = getScrollData(componentEl, contentEl, keyboardHeight);\\r\\n    if (Math.abs(scrollData.scrollAmount) < 4) {\\r\\n        // the text input is in a safe position that doesn't\\r\\n        // require it to be scrolled into view, just set focus now\\r\\n        inputEl.focus();\\r\\n        return;\\r\\n    }\\r\\n    // temporarily move the focus to the focus holder so the browser\\r\\n    // doesn't freak out while it's trying to get the input in place\\r\\n    // at this point the native text input still does not have focus\\r\\n    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\\r\\n    inputEl.focus();\\r\\n    // scroll the input into place\\r\\n    contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration).then(() => {\\r\\n        // the scroll view is in the correct position now\\r\\n        // give the native text input focus\\r\\n        relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\\r\\n        // ensure this is the focused input\\r\\n        inputEl.focus();\\r\\n    });\\r\\n};\\r\\nconst hasPointerMoved = (threshold, startCoord, endCoord) => {\\r\\n    if (startCoord && endCoord) {\\r\\n        const deltaX = (startCoord.x - endCoord.x);\\r\\n        const deltaY = (startCoord.y - endCoord.y);\\r\\n        const distance = deltaX * deltaX + deltaY * deltaY;\\r\\n        return distance > (threshold * threshold);\\r\\n    }\\r\\n    return false;\\r\\n};\\n\\nconst PADDING_TIMER_KEY = '$ionPaddingTimer';\\r\\nconst enableScrollPadding = (keyboardHeight) => {\\r\\n    const doc = document;\\r\\n    const onFocusin = (ev) => {\\r\\n        setScrollPadding(ev.target, keyboardHeight);\\r\\n    };\\r\\n    const onFocusout = (ev) => {\\r\\n        setScrollPadding(ev.target, 0);\\r\\n    };\\r\\n    doc.addEventListener('focusin', onFocusin);\\r\\n    doc.addEventListener('focusout', onFocusout);\\r\\n    return () => {\\r\\n        doc.removeEventListener('focusin', onFocusin);\\r\\n        doc.removeEventListener('focusout', onFocusout);\\r\\n    };\\r\\n};\\r\\nconst setScrollPadding = (input, keyboardHeight) => {\\r\\n    if (input.tagName !== 'INPUT') {\\r\\n        return;\\r\\n    }\\r\\n    if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\\r\\n        return;\\r\\n    }\\r\\n    if (input.parentElement &&\\r\\n        input.parentElement.parentElement &&\\r\\n        input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\\r\\n        return;\\r\\n    }\\r\\n    const el = input.closest('ion-content');\\r\\n    if (el === null) {\\r\\n        return;\\r\\n    }\\r\\n    const timer = el[PADDING_TIMER_KEY];\\r\\n    if (timer) {\\r\\n        clearTimeout(timer);\\r\\n    }\\r\\n    if (keyboardHeight > 0) {\\r\\n        el.style.setProperty('--keyboard-offset', `${keyboardHeight}px`);\\r\\n    }\\r\\n    else {\\r\\n        el[PADDING_TIMER_KEY] = setTimeout(() => {\\r\\n            el.style.setProperty('--keyboard-offset', '0px');\\r\\n        }, 120);\\r\\n    }\\r\\n};\\n\\nconst INPUT_BLURRING = true;\\r\\nconst SCROLL_PADDING = true;\\r\\nconst startInputShims = (config) => {\\r\\n    const doc = document;\\r\\n    const keyboardHeight = config.getNumber('keyboardHeight', 290);\\r\\n    const scrollAssist = config.getBoolean('scrollAssist', true);\\r\\n    const hideCaret = config.getBoolean('hideCaretOnScroll', true);\\r\\n    const inputBlurring = config.getBoolean('inputBlurring', true);\\r\\n    const scrollPadding = config.getBoolean('scrollPadding', true);\\r\\n    const inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\\r\\n    const hideCaretMap = new WeakMap();\\r\\n    const scrollAssistMap = new WeakMap();\\r\\n    const registerInput = (componentEl) => {\\r\\n        const inputEl = (componentEl.shadowRoot || componentEl).querySelector('input') || (componentEl.shadowRoot || componentEl).querySelector('textarea');\\r\\n        const scrollEl = componentEl.closest('ion-content');\\r\\n        if (!inputEl) {\\r\\n            return;\\r\\n        }\\r\\n        if ( !!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\\r\\n            const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\\r\\n            hideCaretMap.set(componentEl, rmFn);\\r\\n        }\\r\\n        if ( !!scrollEl && scrollAssist && !scrollAssistMap.has(componentEl)) {\\r\\n            const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, keyboardHeight);\\r\\n            scrollAssistMap.set(componentEl, rmFn);\\r\\n        }\\r\\n    };\\r\\n    const unregisterInput = (componentEl) => {\\r\\n        if ( hideCaret) {\\r\\n            const fn = hideCaretMap.get(componentEl);\\r\\n            if (fn) {\\r\\n                fn();\\r\\n            }\\r\\n            hideCaretMap.delete(componentEl);\\r\\n        }\\r\\n        if ( scrollAssist) {\\r\\n            const fn = scrollAssistMap.get(componentEl);\\r\\n            if (fn) {\\r\\n                fn();\\r\\n            }\\r\\n            scrollAssistMap.delete(componentEl);\\r\\n        }\\r\\n    };\\r\\n    if (inputBlurring && INPUT_BLURRING) {\\r\\n        enableInputBlurring();\\r\\n    }\\r\\n    if (scrollPadding && SCROLL_PADDING) {\\r\\n        enableScrollPadding(keyboardHeight);\\r\\n    }\\r\\n    // Input might be already loaded in the DOM before ion-device-hacks did.\\r\\n    // At this point we need to look for all of the inputs not registered yet\\r\\n    // and register them.\\r\\n    for (const input of inputs) {\\r\\n        registerInput(input);\\r\\n    }\\r\\n    doc.addEventListener('ionInputDidLoad', ((ev) => {\\r\\n        registerInput(ev.detail);\\r\\n    }));\\r\\n    doc.addEventListener('ionInputDidUnload', ((ev) => {\\r\\n        unregisterInput(ev.detail);\\r\\n    }));\\r\\n};\\n\\nexport { startInputShims };\\n\"]}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{\"WI/H\":function(t,e,n){\"use strict\";n.r(e),n.d(e,\"startInputShims\",(function(){return u}));var o=n(\"9Xoc\");const r=new WeakMap,s=(t,e,n,o=0)=>{r.has(t)!==n&&(n?i(t,e,o):l(t,e))},a=t=>t===t.getRootNode().activeElement,i=(t,e,n)=>{const o=e.parentNode,s=e.cloneNode(!1);s.classList.add(\"cloned-input\"),s.tabIndex=-1,o.appendChild(s),r.set(t,s);const a=\"rtl\"===t.ownerDocument.dir?9999:-9999;t.style.pointerEvents=\"none\",e.style.transform=`translate3d(${a}px,${n}px,0) scale(0)`},l=(t,e)=>{const n=r.get(t);n&&(r.delete(t),n.remove()),t.style.pointerEvents=\"\",e.style.transform=\"\"},c=\"input, textarea, [no-blur]\",d=(t,e)=>{if(\"INPUT\"!==t.tagName)return;if(t.parentElement&&\"ION-INPUT\"===t.parentElement.tagName)return;if(t.parentElement&&t.parentElement.parentElement&&\"ION-SEARCHBAR\"===t.parentElement.parentElement.tagName)return;const n=t.closest(\"ion-content\");if(null===n)return;const o=n.$ionPaddingTimer;o&&clearTimeout(o),e>0?n.style.setProperty(\"--keyboard-offset\",`${e}px`):n.$ionPaddingTimer=setTimeout(()=>{n.style.setProperty(\"--keyboard-offset\",\"0px\")},120)},u=t=>{const e=document,n=t.getNumber(\"keyboardHeight\",290),r=t.getBoolean(\"scrollAssist\",!0),i=t.getBoolean(\"hideCaretOnScroll\",!0),l=t.getBoolean(\"inputBlurring\",!0),u=t.getBoolean(\"scrollPadding\",!0),m=Array.from(e.querySelectorAll(\"ion-input, ion-textarea\")),p=new WeakMap,f=new WeakMap,E=t=>{const e=(t.shadowRoot||t).querySelector(\"input\")||(t.shadowRoot||t).querySelector(\"textarea\"),l=t.closest(\"ion-content\");if(e){if(l&&i&&!p.has(t)){const n=((t,e,n)=>{if(!n||!e)return()=>{};const o=n=>{a(e)&&s(t,e,n)},r=()=>s(t,e,!1),i=()=>o(!0),l=()=>o(!1);return n.addEventListener(\"ionScrollStart\",i),n.addEventListener(\"ionScrollEnd\",l),e.addEventListener(\"blur\",r),()=>{n.removeEventListener(\"ionScrollStart\",i),n.removeEventListener(\"ionScrollEnd\",l),e.addEventListener(\"ionBlur\",r)}})(t,e,l);p.set(t,n)}if(l&&r&&!f.has(t)){const r=((t,e,n,r)=>{let i;const l=t=>{i=Object(o.j)(t)},c=l=>{if(!i)return;const c=Object(o.j)(l);((t,e,n)=>{if(e&&n){const t=e.x-n.x,o=e.y-n.y;return t*t+o*o>36}return!1})(0,i,c)||a(e)||(l.preventDefault(),l.stopPropagation(),((t,e,n,o)=>{const r=((t,e,n)=>((t,e,n,o)=>{const r=t.top,s=t.bottom,a=e.top,i=a+15,l=.5*Math.min(e.bottom,o-n)-s,c=i-r,d=Math.round(l<0?-l:c>0?-c:0),u=Math.min(d,r-a),m=Math.abs(u);return{scrollAmount:u,scrollDuration:Math.min(400,Math.max(150,m/.3)),scrollPadding:n,inputSafeY:4-(r-i)}})((t.closest(\"ion-item,[ion-item]\")||t).getBoundingClientRect(),e.getBoundingClientRect(),n,t.ownerDocument.defaultView.innerHeight))(t,n,o);Math.abs(r.scrollAmount)<4?e.focus():(s(t,e,!0,r.inputSafeY),e.focus(),n.scrollByPoint(0,r.scrollAmount,r.scrollDuration).then(()=>{s(t,e,!1,r.inputSafeY),e.focus()}))})(t,e,n,r))};return t.addEventListener(\"touchstart\",l,!0),t.addEventListener(\"touchend\",c,!0),()=>{t.removeEventListener(\"touchstart\",l,!0),t.removeEventListener(\"touchend\",c,!0)}})(t,e,l,n);f.set(t,r)}}};l&&(()=>{let t=!0,e=!1;const n=document;n.addEventListener(\"ionScrollStart\",()=>{e=!0}),n.addEventListener(\"focusin\",()=>{t=!0},!0),n.addEventListener(\"touchend\",o=>{if(e)return void(e=!1);const r=n.activeElement;if(!r)return;if(r.matches(c))return;const s=o.target;s!==r&&(s.matches(c)||s.closest(c)||(t=!1,setTimeout(()=>{t||r.blur()},50)))},!1)})(),u&&(t=>{const e=document;e.addEventListener(\"focusin\",e=>{d(e.target,t)}),e.addEventListener(\"focusout\",t=>{d(t.target,0)})})(n);for(const o of m)E(o);e.addEventListener(\"ionInputDidLoad\",t=>{E(t.detail)}),e.addEventListener(\"ionInputDidUnload\",t=>{(t=>{if(i){const e=p.get(t);e&&e(),p.delete(t)}if(r){const e=f.get(t);e&&e(),f.delete(t)}})(t.detail)})}}}]);","extractedComments":[]}